<!DOCTYPE html>
<html lang="en">




<head>

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>Search - Liuzj的博客</title>
  

  
  
  <meta name="description" content="Android developer">
  <meta name="author" content="Liuzj">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>


<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script
src="https://code.jquery.com/jquery-3.3.1.min.js"
integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


 

  <!-- load font awesome 5 -->
  <script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  

  <!-- include comment system code -->
  
    <script src="//cdn1.lncld.net/static/js/3.6.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class='header'>
	<div class="header-title">
		
		<div class='header-logo'>
			<a href='/'>
				<img src='/images/avatar.png' />
			</a>
		</div>
		<div class='header-text'>
			<h1>
				<a href="/">Liuzj的博客</a>
			</h1>
			<subtitle>
				思考一切
			</subtitle>
		</div>
		
	</div>
	<div id='header-nav'>
		



<nav id="nav">
	
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='Archives'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='Search'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
		
		
	</div>
	</div>
</nav>

	</div>
</header>

 




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <div class='search-container'>
	<input type="text" id='search-form'>

	<ul class="cat-list">
		
	</ul>

	<div class="archive-cards">
			<div class='Card-archive' style='display:none'>
				<div class="Card-body">
					<h3 class='Card-title'>
						<a>
						</a>
					</h3>
					<div class="Card-meta">
						<ul>
							<li><i class='fa fa-calendar'></i> <span class='Card-date'></span></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
</div>

<script src="/libs/fuse.js/dist/fuse.min.js"></script>
<script>
	var options = {
		shouldSort: true,
		threshold: 0.4,
		tokenize: true,
		location: 0,
		distance: 100,
		maxPatternLength: 32,
		minMatchCharLength: 2,
		keys: [
			"title",
			"author",
			"tags"
		]
	};
	var s = '[{"title":"Activity总结","date":"2018-05-08T07:42:21.000Z","content":"看了标题也许你会想，也许你会说，activity我天天用，我最了解不过了，没有什么是我不清楚的。你怕是在唬我吧？那下面就看看我说的这些你都了解嘛\n基础知识\n正常情况下的生命周期\nonCreate：表示Activity正在被创建，我们可以做一些初始化工作，没啥子可说的。\n\nonRestart：当当前Activity从不可见重新变为可见状态时，该方法会被调用。\n\nonStart：这时Activity已经可见的，但是处于后台，无法和用户交互。\n\nonResume：这时Activity已经可见的，但是处于前台。\n\nonPause：在这个方法可以做一些存储数据，停止动画的操作，但是不能太耗时，因为这会影响到新Activity的显示，onPause必须执行完，新Activity的onResume才会执行。\n\nonStop:Activity即将停止，可以做一些稍微重量级的回收工作，同样不能太耗时。\n\nonDestory:表示Activity即将销毁，我们可以做一些回收工作和资源释放工作。\nActivity第一次启动会调用onCreate–&gt;onStart–&gt;onResume,当用户打开新的Activity或者切换到桌面的时候，会调用onPause–&gt;onStop，如果这个Activity采用透明主题，不会调用onStop,是因为新Activity透明主题我们还能看到下面那个之前Activity，所以不会调用onStop，再回到原Activity时调用onRestart–&gt;onStart–&gt;onResume.\n\n\n\n异常情况下的生命周期\n资源相关的系统配置发生改变导致Avtivity被杀死并重新创建\n\n资源不足时导致优先级低的Activity被杀死\n\n…\nActivity会调用onSaveInstanceState方法，系统自动为我们做了一定的恢复工作，并且重启为我们恢复这些数据，比如文本框中用户输入的数据，listView滚动位置等，具体的我们可以查看特定View的源码。\n\n\n\nActivity的启动模式  1、使用场景\n\nstandard：当需要每次请求都新开一个实例的时候，比如，浏览器开多个浏览窗口。\n\nsingleTop：适合作为接受通知的启动界面，比如，客户端收到10条推送，如果是标准模式，分别点击这10个推送，就会启动10个这样的显示内容的界面，而如果是singleTop，则只会打开一个显示界面。\n\nsingleTask：适合作为程序的入口，不管其他程序打开该界面多少次，都只会在任务栈中存在一份，比如浏览器的启动界面。\n\nsingleInstance：适合永远都不会变化的界面，比如闹钟的提醒界面，在比如拨号程序的呼叫界面。\n2、IntentFilter的匹配规则\n\naction的匹配规则：要求Intent中的action存在且必须和过滤规则中的其中一个action相同，这个区分大小写，如果相同的字符串，大小写字母不同，action会匹配失败。\n\ncategory匹配规则：这个可有可无，如果有，则必须和过滤规则中的其中一个category相同，如果不写的话，在启动Activity时系统会自动加上”android.intent.category.DEFAULT”\n\ndata可进一步分为uri（由scheme、host、port、path | pathPattern | pathPrefix这4部分组成）和mimetype。Intent的uri可通过setData方法设置，mimetype可通过setType方法设置。隐式Intent也必须指定data。同action类似，只要Intent的data只要与Intent Filter中的任一个data声明完全相同，data方面就匹配成功。需要注意的是：若Intent Filter的data声明部分未指定uri，则缺省uri为content或file，Intent中的uri的scheme部分需为content或file才能匹配；若要为Intent指定完整的data，必须用setDataAndType方法，原因请看setData和setType方法的源码：\n\n\n\n\n\npublic Intent setData(Uri data) {\n    mData = data;\n    mType = null;\n    return this;\n}\n\npublic Intent setType(String type) {\n    mData = null;\n    mType = type;\n    return this;\n}\n\n\n从以上代码可以看到，setData会把mimeType置为null，setType会把uri置为null。下面我们来举例说明一下data的匹配。首先我们先来看一下Intent Filter中指定data的语法：\n&lt;data android:scheme=&quot;...“ \n      android:host=&quot;...&quot;\n      android:port=&quot;...&quot;\n      android:path=&quot;...&quot;\n      android:pathPattern=&quot;...&quot;\n      android:pathPrefix=&quot;...&quot;\n      android:mimeType=&quot;...&quot; /&gt;\n其中scheme、host等各个部分无需全部指定。假如我们为MyActivity的Intent Filter指定了如下data：\n&lt;intent-filter&gt;\n    &lt;data android:mimeType=&quot;vidoe/mpeg&quot; android:scheme=&quot;http&quot; android:host=&quot;www.xxx.com&quot; /&gt;\n    &lt;data android:mimeType=&quot;text/plain&quot; android:scheme=&quot;http&quot; /&gt;\n&lt;/intent-filter&gt;\n那么我们的Intent想要匹配，mimeType可以为”text/plain”或“video/mpeg”,scheme必须为”http“，host则没有限制，因为第二个data没有指定host。\n最后这就是我知道的关于activity的一些知识，若有叙述不清晰或是不准确的地方希望大家指出，如果你知道更多知识，欢迎给我评论，大家一起学习进步。谢谢观看\n参考资料 《Android开发艺术探索》","tags":["四大组件","Activity"],"path":"2018/05/08/Activity总结/","external_link":""},{"title":"Android Studio SVN使用手册","date":"2016-09-05T16:00:00.000Z","content":"Android Studio 配置及使用：\n下载客户端：下载地址:http://tortoisesvn.net/downloads.html\n安装配置：这个需要自己独立安装带有 command line 功能的 SVN 客户端，据说 1.7 之后开始支持 command line 模式。如图，安装时必须自定义选择 command line 否则不会安装的安装完成后，打开 IDE 的 setting 配置面板：如上图路径 Version Control 下的 Subersion 设置：Use Command Line Client 选择浏览到你本地安装 TortoiseSVN 的 svn.exe 文件路径，如下图：（注意输入框最右侧有个浏览的按钮，有可能没显示出来，拉伸窗口即可见）然后在setting 点击Version Control，配置成下图样子3.提交、签出 SVN 这个比较繁琐的也是容易出错的（当然你会了也就不繁琐了 哈哈）：推荐使用这种方式，先share到服务器指定目录，这样做的意思是，先和服务器建立链接，注意share完之后服务器还是没有你的代码，只是单纯的和服务器建立了链接关系。如果想让你的代码同步到服务器则需要commit一下，commit之后你的代码就正式传到服务器上了。这时你在修改文件就会变颜色，每种颜色都对应一种状态，具体的自己体会吧。特别说明一点：如果不需要提交忽略文件到服务器的话，需要在和服务器建立关联（share）之前添加忽略文件，之后添加忽略仿佛没有什么效果。在Android中不推荐直接把项目import到服务器，因为这样在以后并没有和服务器建立关联，也就导致在以后工作中会出现一些问题，具体问题可百度，有很多，楼主在这就不详细说了\nIgnore 指定忽略文件或目录AndroidStudio 的 Setting–&gt;Version control –&gt;Ignored files，具体怎么添加忽略文件我也不说了，网上也有很多教程然后就可以提交到服务器了,对于更新和提交这两个小按钮很方面操作，向上的绿色是commit ，向下的蓝色 是 update注意：SVN是以服务器为准的，如果需要更新，首先需要把服务器上的checkout到本地，然后在Update project 如果update后服务器没有修改，则需要commit changes更新操作:如在MainActivity中添加了几行注释：这时SVN就会用本地文件对照服务器，发现有修改的文件，就会把对应的文件名变色如果要更新的话，点击向下箭头，update project弹出这个界面，选ok下面的version control就会有所提示这样我们就可以看到Version control 提示更新了，MainActivity文件颜色也和其他的一样了。我也时才从这个坑跳出来，希望能帮到你，如果有什么问题请在下面评论，我会认真看的。最后别忘了给我点赞哦\n\n","tags":["SVN","使用手册"],"path":"2016/09/06/Android Studio SVN使用手册/","external_link":""},{"title":"Android开发配置wifi调试教程","date":"2016-12-17T16:00:00.000Z","content":"背景由于之前一直用数据线调试，手机连接电脑，手机一直处于充电状态，就导致了电池特别不着用，开始充一次电可以用两天左右，调试了不到俩月，现在充满电用不了一天就没电了。所以还是推荐通过wifi调试，第一对手机电池好，第二炫酷呀，可以装x。哈哈，下面我介绍两种方式：\n第一种：针对没数据线时这种情况第一步、需要手机先下载个安卓终端模拟器，当然去网上搜也有很多的，打开终端，依次执行下面步骤第二步、点击你连接的wifi，然后看下面有你的ip地址，记下来第三步、在电脑上，上运行cmd命令提示符，键入如下命令：\nadb connect 上一步让你记得ip地址:5555\n如果没有把adb配置到环境变量里，则需要要先 cd到adb的目录中在执行上述步骤如果提示连接成功，则说明搞定了。\n第二种：针对Android Studio，相对第一种简单很多第一步、先打开安卓studio的Settings-&gt; Plugins-&gt; Browse Repositories，在里面搜索ADB WiFI第二步，重启studio，哈哈第三步、也是关键的一步，直接看下图直接点击ADB USB to WIFI就ok了。\n最后体验炫酷的wifi调试吧。\n","tags":["Wifi调试","Android 开发"],"path":"2016/12/18/Android开发配置wifi调试教程/","external_link":""},{"title":"EventBus使用笔记","date":"2017-03-01T16:00:00.000Z","content":"概念EventBus是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。&lt;a href=“https://github.com/greenrobot/EventBus”&gt;EventBus源码点我使用1、准备工作因为我使用的是Android Studio，所以第一步要添加依赖：\n￼\n2、基本用法1、在需要接收事件分发的页面注册EventBusEventBus.getDefault().register(this);\n2、在第二个页面或其他需要发送事件，发送事件使用的是post方法，里面是一个object参数，我们可以自己定义一个类，然后把这个实例传递进去EventBus.getDefault().post(new EventParam());\n3、当然就是在注册事件分发的页面接收传递过来的事件了，有四种方法：  onEvent()：在哪个线程发的消息，就在哪个线程执行。 onEventMainThread()：无论在哪个线程发布，都在主线程执行 onEventBackground()：如果在主线程发布的，他会在子线程执行，如果在子线程发布，那么他会在其他子线程执行。 onEventAsync()：无论在哪个线程发布的都会新创建一个线程执行\n4、一定要在注册EventBus结束的时候解除绑定 EventBus.getDefault().unregister(this);\n3、进阶，上面已经说了四个方法的使用了，下面说下怎么区别这四个方法。 就一句话，根据传递进来的参数，参数相同的就会被执行，不同的则不执行\n","tags":["EventBus"],"path":"2017/03/02/EventBus使用笔记/","external_link":""},{"title":"Git 操作","date":"2017-11-20T16:00:00.000Z","content":"git 命令\n创建本地仓库\n\n1git init\n\n获取远程仓库\n\n12git clone [url]例：git clone https://github.com/you/yourpro.git\n\n创建远程仓库\n\n12345678910111213141516// 添加一个新的 remote 远程仓库git remote add [remote-name] [url]例：git remote add origin https://github.com/you/yourpro.gitorigin：相当于该远程仓库的别名// 列出所有 remote 的别名git remote// 列出所有 remote 的 urlgit remote -v// 删除一个 renotegit remote rm [name]// 重命名 remotegit remote rename [old-name] [new-name]\n\n从本地仓库中删除\n\n123git rm file.txt         // 从版本库中移除，删除文件git rm file.txt -cached // 从版本库中移除，不删除原始文件git rm -r xxx           // 从版本库中删除指定文件夹\n\n从本地仓库中添加新的文件\n\n12git add .               // 添加所有文件git add file.txt        // 添加指定文件\n\n提交，把缓存内容提交到 HEAD 里\n\n1git commit -m 注释\n\n撤销\n\n1234567891011// 撤销最近的一个提交.git revert HEAD// 取消 commit + addgit reset --mixed// 取消 commitgit reset --soft// 取消 commit + add + local workinggit reset --hard\n\n把本地提交 push 到远程服务器\n\n12git push [remote-name] [loca-branch]:[remote-branch]例：git push origin master:master\n\n查看状态\n\n1git status\n\n从远程库中下载新的改动\n\n1git fetch [remote-name]/[branch]\n\n合并下载的改动到分支\n\n1git merge [remote-name]/[branch]\n\n从远程库中下载新的改动\n\n1234pull = fetch + mergegit pull [remote-name] [branch]例：git pull origin master\n\n分支\n\n1234567891011// 列出分支git branch// 创建一个新的分支git branch (branch-name)// 删除一个分支git branch -d (branch-nam)// 删除 remote 的分支git push (remote-name) :(remote-branch)\n\n切换分支\n\n12345// 切换到一个分支git checkout [branch-name]// 创建并切换到该分支git checkout -b [branch-name]\n与github建立ssh通信，让Git操作免去输入密码的繁琐。\n首先呢，我们先建立ssh密匙。\n\nssh key must begin with ‘ssh-ed25519’, ‘ssh-rsa’, ‘ssh-dss’, ‘ecdsa-sha2-nistp256’, ‘ecdsa-sha2-nistp384’, or ‘ecdsa-sha2-nistp521’.  – from github\n\n根据以上文段我们可以知道github所支持的ssh密匙类型，这里我们创建ssh-rsa密匙。在command line 中输入以下指令:ssh-keygen -t rsa去创建一个ssh-rsa密匙。如果你并不需要为你的密匙创建密码和修改名字，那么就一路回车就OK，如果你需要，请您自行Google翻译，因为只是英文问题。\n\n$ ssh-keygen -t rsaGenerating public/private rsa key pair.//您可以根据括号中的路径来判断你的.ssh文件放在了什么地方Enter file in which to save the key (/c/Users/Liang Guan Quan/.ssh/id_rsa):\n\n\n到 https://github.com/settings/keys 这个地址中去添加一个新的SSH key，然后把你的xx.pub文件下的内容文本都复制到Key文本域中，然后就可以提交了。\n\n添加完成之后 我们用ssh git@github.com 命令来连通一下github，如果你在response里面看到了你github账号名，那么就说明配置成功了。  let’s enjoy github ;)\n\ngitignore\n在本地仓库根目录创建 .gitignore 文件,可以github搜索gitignore，然后下载对应的文件丢到自己项目里即可。Win7 下不能直接创建，可以创建 “.gitignore.” 文件，后面的标点自动被忽略；\n1234/.idea          // 过滤指定文件夹/fd/*           // 忽略根目录下的 /fd/ 目录的全部内容；*.iml           // 过滤指定的所有文件!.gitignore     // 不忽略该文件\n","tags":["git","工具"],"path":"2017/11/21/Git操作/","external_link":""},{"title":"IPC的理解","date":"2017-05-08T16:00:00.000Z","content":"IPC\nInter-Process Communication的缩写。含义为进程间通信或跨进程通信，是指两个进程之间进行数据交换的过程。\n\n进程和线程的区别\n按照操作系统的描述，线程是CPU调度的最小单元，同时线程是一种有限的系统资源。\n进程一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程，因此进程和线程是包含与被包含的关系。\n\n多进程分为两种\n第一种情况是一个应用因为某些原因自身需要采用多线程模式来实现。\n另一种情况是当前应用需要向其他应用获取数据\n\nAndroid中的多进程模式通过给四大组件指定android:process属性，我们可以开启多线程模式\n\n进程名以”:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一进程，而进程名不以”:”开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。\nAndroid系统会为每个应用分配一个唯一的UID,具有相同UID的应用才能共享数据，两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享data目录、组件信息，还可以共享内存数据，或者说它们看起来就像是一个应用的两个部分。\n\n多进程模式的运行机制\nAndroid为每一个应用分配了一个独立的虚拟机，或者说为每个进程都分配了一个独立的虚拟机，不同的虚拟机在不同的内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生多份副本。\n所有运行在不同进程中的四大组件，只要它们之间需要通过内存来共享数据，都会共享失败。\n\n一般来说，使用多进程会造成如下几个方面的问题：\n\n静态成员和单例模式完全失效\n线程同步机制完全失效\n\n不管是锁对象还是锁全局类都无法保证线程同步，因为不同进程锁的不是同一个对象\n\nSharedPreference的可靠性下降\n\nSharedPreferences不支持两个进程同时去执行写操作，否则会导致一定几率的数据丢失，这时因为SharedPreferences底层是通过读写XML文件来实现的，并发写显然是可能出问题的，甚至并发读写都有可能发生问题\n\nApplication会多次创建\n\n运行在同一个进程中的组件是属于同一个虚拟机和同一个Application的。同理，运行在不同进程中的组件是属于两个不同的虚拟机和Application的。\nIPC基础概念介绍\nSerializable\n\n是Java所提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。使用Serializable来实现序列化相当简单，只需要在类的声明中指定一个类似下面的标识即可自动实现默认的序列化过程。\n12private static final long serialVersionUID = 8711368828010083044L\n通过Serializable方来实现对象的序列化，如下代码：1234567891011//序列化过程User user = new User(0, jake, true);ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(cache.txt));out.writeObject(user);out.close();//反序列化过程ObjectInputStream in = new ObjectInputStream(new FileInputStream(cache.txt));User newUser = (User)in.readObject();in.close();\n原则上序列化后的数据中的serialVersionUID只有和当前类的serialVersionUID相同时才能够正常的被反序列化。serialVersionUID的详细工作机制是这样的：序列化的时候系统会把当前类的serialVersionUID写入序列化的文件中（也可能是其他的中介），当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化，否则就说明当前类和序列化的类相比发生了某些变换\n给serialVersionUID制定为1L或者采用Eclipse根据当前类结构去生成的hash值，这两者并没有本质区别。\n\n静态成员变量属于类不属于对象，所以不会参与序列化过程\n其次用transient关键字标记的成员变量不参与序列化过程\n\nParcelable接口Parcelable也是一个接口，只要实现这个接口，一个类的对象就可以实现序列化并可以通过Intent的Binder传递Parcelable的方法说明：\n\n\n\n方法\n功能\n标记位\n\n\n\n\ncreateFromParcel(Parcel in)\n从序列化的对象中创建原始对象\n\n\n\nnewArray[int size]\n创建指定长度的原始对象数组\n\n\n\nUser(Parcel in)\n从序列化的对象中创建原始对象\n\n\n\nwrite ToParcel(Parcel out, int flags)\n将当前对象写入序列化结构中，其中flags标识有两种值0或1（参见右侧标记位）。为1时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0\nPARCELABLE_WRITE_RETURN_VALUE\n\n\ndescribeContents\n返回当前对象的内容描述。如果含有文件描述符，返回1（参见右侧标记位），否则返回0，几乎所有的情况都返回0\nCONTENTS_FILE_DESCRIPTOR\n\n\n\n\n系统已经为我们提供了许多实现了Parcelable接口的类，它们都是可以直接序列化的，比如Intent、Bundle、Bitmap等，同时List和Map也可以序列化，前提是它们里面的每个元素都是可序列化的。\n\n如何选取Serializable是Java中的序列化接口，其使用起来简单但是开销很大，序列化和反序列化需要大量I/O操作。而Parceleble是Android中的序列化方式，因此更适合在Android平台上，缺点是麻烦，但是效率高，这是Android推荐的序列化方式，所以我们要首选Parcelable。Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化之后通过网络传输，但是过程稍显复杂，因此在这两种情况下建议大家使用Serializable。\nBinder\n继承了IBinder接口\nBinder是一种跨进程通信方式\n是ServiceManager连接各种Manager（ActivityManager,WindowManager等）和相应ManagerService的桥梁\n从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务器会返回一个包含了服务器端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者是数据，这里的服务包含了普通服务和基于AIDL的服务\n\naidl工具根据aidl文件自动生成的java接口的解析：首先，它声明了几个接口方法，同时还声明了几个整型的id用于标识这些方法，id用于标识在transact过程中客户端所请求的到底是哪个方法；接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部的代理类Proxy来完成。所以，这个接口的核心就是它的内部类Stub和Stub内部的代理类Proxy。 下面分析其中的方法：\n\nasInterface(android.os.IBinder obj):用于将服务器端的Binder对象转化成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端是在同一进程中，那么这个方法返回的是服务端的Stub对象本身，否则返回的是系统封装的Stub.Proxy对象。\nasBinder:返回当前Binder对象\nonTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。这个方法的原型是public Boolean onTransact(int code, Parcelable data, Parcelable reply, int flags)服务端通过code可以知道客户端请求的目标方法，接着从data中取出所需的参数，然后执行目标方法，执行完毕之后，将结果写入到reply中。如果此方法返回false，说明客户端的请求失败，利用这个特性可以做权限验证(即验证是否有权限调用该服务)。\nProxy#[Method]：代理类中的接口方法，这些方法运行在客户端，当客户端远程调用此方法时，它的内部实现是：首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。\n\n首先，当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，所以如果一个远程方法是很耗时的，那么不能在UI线程发起此远程请求；其次，由于服务端的Binder方法运行在Binder的线程池中，所以不管Binder是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了。Binder两种重要的方法\nlinkToDeath\nunlinkToDeathBinder运行在服务端，如果由于某种服务端异常终止了的话会导致客户端的远程调用失败、所以Binder提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath方法可以给Binder设置一个死亡代理，当Binder死亡的时候客户端就会收到通知，然后就可以重新发起连接从而恢复连接了。如何给Binder设置死亡代理1、声明一个DeathRecipient对象、DeathRecipient是一个接口，其内部只有一个方法bindDied，实现这个方法就可以在Binder死亡的时候收到通知了。\n\n12345678910private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() &#123;    @Override    public void binderDied() &#123;        if (mRemoteBookManager == null) return;        mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, 0);        mRemoteBookManager = null;        // TODO:这里重新绑定远程Service    &#125;&#125;;\n2、在客户端绑定远程服务成功之后，给binder设置死亡代理\n12mRemoteBookManager.asBinder().linkToDeath(mDeathRecipient, 0);\nAndroid的IPC方式1、 使用Bundle\nBundle实现了Parcelable接口，Activity、Service和Receiver都支持在Intent中传递Bundle数据\n2、 使用文件共享\n这种方式简单，适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题，SharedPreferences是一个特例，虽然它也是文件的一种，但是由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下、系统对它的读写就变的不可靠，当面对高并发读写访问的时候，有很大几率会丢失，因此，不建议在进程间通信中使用SharedPreferences。\n3、 使用Messenger\nMessenger是一种轻量级的IPC方案，它的底层实现就是AIDL。Messenger是以串行的方式处理请求的，即服务端只能一个个处理，不存在并发执行的情形。\n4、 使用AIDL\n大致流程：首先建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。1.AIDL支持的数据类型：基本数据类型、String和CharSequence、ArrayList、HashMap、Parcelable以及AIDL；2.某些类即使和AIDL文件在同一个包中也要显式import进来；3.AIDL中除了基本数据类，其他类型的参数都要标上方向：in、out或者inout；4.AIDL接口中支持方法，不支持声明静态变量；5.为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。6.RemoteCallbackList是系统专门提供的用于删除跨进程Listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，因为所有的AIDL接口都继承自IInterface接口。\n5、使用ContentProvider\n1.ContentProvider主要以表格的形式来组织数据，并且可以包含多个表；2.ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider；3.ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行；4.要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者；\n6、使用Socket\n套接字，分为流式套接字和用户数据报套接字两种，分别对应于网络的传输控制层中TCP和UDP协议。\n\nTCP协议是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过”三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传功能，因此具有很高的稳定性\nUDP是无连接的，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能，在性能上，UDP具有更好的效率，其缺点是不保证数据能够正确传输，尤其是在网络拥塞的情况下。\n\nBinder连接池\n当项目规模很大的时候，创建很多个Service是不对的做法，因为service是系统资源，太多的service会使得应用看起来很重，所以最好是将所有的AIDL放在同一个Service中去管理。整个工作机制是：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。\n建议在AIDL开发工作中引入BinderPool机制。\n\n选用合适的IPC方式\n","tags":["IPC","《Android开发艺术探索》","读书笔记"],"path":"2017/05/09/《Android开发艺术探索》第二章笔记/","external_link":""},{"title":"丢掉系统自带的矮挫丑Toast吧，打造属于你自己的Toast","date":"2016-11-03T16:00:00.000Z","content":"背景  在我们平时做demo，用系统自带的土司还可以。但是当我们在做项目的时候，如果还用系统再带的，那可能就有点low咯。所以让我们一起来打造好看的土司吧。\n效果图哈哈 或许我设计的不是太美观，但是颜色样式位置你都可以自定义，相信你会设计出更好的来\n代码实现官方提供这些方法就是方便我们原来自定义Toast的下面我们来一起看看怎么利用这些方法打造好看的土司吧\n第一步 我们首先建一个用于包装系统土司的类，然后把我们需要修改的内容传给我们定义的土司，然后在调用系统土司的方法，最后显示。第二步 我们利用LayoutInflater来构造我们想要自定义的布局作为土司的布局，首先把我们定义的布局引入，并初始化控件\n第三步 我们要给土司设置显示的文字，也就是在之前初始化控件的时候我们自己写的那个textView，现在用我们自己定义的布局来显示要土司的内容，我们当然可以也写一个方法，方便下面我们的使用\n第四步 现在我们就正式的对系统的土司妹妹动手脚咯 嘿嘿~ 如果想修改我们自定义土司的位置，可以调用系统的这个方法来实现这里多说一下，这个方法包含四个参数，第一个是土司的显示位置，我设置的是显示在中间位置，第二个参数是在x轴的位置，正数表示往右，负数往左，第三个参数是y轴的位置，正数表示往下，负数往上。这个大家可以改下参数一试便知\n第五步 土司的显示时间，这个就简单多了，直接上代码了\n第六步 就是让土司显示了，如果不显示再好看的土司我们也看不到啊\n最后一步就是模仿土司的使用了，我是这样搞的，你怎么搞都行 当然可以在封装一层使之更简洁\n总结简单几步打造属于你自己的土司，是不是有点过于简单了呢，如果喜欢就在下面给我点赞哦，如果有那描述的不清晰的也欢迎给我留言问我哦。源码点我点我点我","tags":["Toast","UI"],"path":"2016/11/04/丢掉系统自带的矮挫丑Toast吧，打造属于你自己的Toast/","external_link":""},{"title":"仿QQ好友点赞效果，属性动画+贝塞尔曲线实现","date":"2018-05-08T16:00:00.000Z","content":"前言属性动画 和 贝赛尔曲线 已经出来很久了，很多前辈写了很多不错的文章，在此不得不感谢这些前辈无私奉献的开源精神，能让我们站在巨人的肩膀上望得更远.如果你对属性动画还不太了解可以看看郭林的文章，贝塞尔曲线的使用可以参考Lin_Zero\n效果图\n实现思路整体实现思路还是比较简单的，首先要有一个容器来装点出来的赞，然后通过属性动画对赞加一些动画效果，最后通过贝塞尔曲线使其做不规则的运动。\n代码实现好了，思路有了，咱们也废话不多说，直接上代码，首先是所有动画的实现1234567891011121314151617181920212223242526272829303132333435363738/** *  实现点赞效果 平移 缩放 渐变 * @param imageView * @return 所有动画的集合 */private AnimatorSet getAnimator(final ImageView imageView) &#123;    //缩放    ObjectAnimator scaleX = ObjectAnimator.ofFloat(imageView,scaleX,0.4f,1f);    ObjectAnimator scaleY = ObjectAnimator.ofFloat(imageView,scaleY,0.4f,1f);    //alpha    ObjectAnimator alpha = ObjectAnimator.ofFloat(imageView,alpha,0.4f,1f);    //执行三个动画    AnimatorSet enterSet = new AnimatorSet();    enterSet.setDuration(500);    enterSet.playTogether(scaleX,scaleY,alpha);    //用贝塞尔曲线控制点赞的走向    ValueAnimator bezierAnimator = getBezierAnimator(imageView);    //综合所有动画    AnimatorSet set = new AnimatorSet();    //按顺序执行    set.playSequentially(enterSet,bezierAnimator);    //添加插值器    set.setInterpolator(interpolators[random.nextInt(3)]);    set.setTarget(imageView);    set.addListener(new AnimatorListenerAdapter() &#123;        @Override        public void onAnimationEnd(Animator animation) &#123;            super.onAnimationEnd(animation);            removeView(imageView);        &#125;    &#125;);    return set;&#125;\n然后是通过贝塞尔曲线对赞的走向做了控制，代码如下1234567891011121314151617181920212223242526272829/** * 通过贝塞尔曲线对赞走向做控制 * @param imageView * @return */private ValueAnimator getBezierAnimator(final ImageView imageView) &#123;    //准备控制贝塞尔曲线的四个点（起始点p0,拐点p1,拐点p2,终点p3）    PointF pointF0 = new PointF((mWidth-dWidth)/2,mHeight-dHeight);    PointF pointF1 = getTogglePointF(1);    PointF pointF2 = getTogglePointF(2);    PointF pointF3 = new PointF(random.nextInt(mWidth),0);    BezierEvaluator bezierEvaluator = new BezierEvaluator(pointF1,pointF2);    final ValueAnimator animator = ValueAnimator.ofObject(bezierEvaluator,pointF0,pointF3);    animator.setDuration(3000);    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;        @Override        public void onAnimationUpdate(ValueAnimator valueAnimator) &#123;            PointF pointF = (PointF) valueAnimator.getAnimatedValue();            //控制属性变化            imageView.setX(pointF.x);            imageView.setY(pointF.y);            imageView.setAlpha(1 - valueAnimator.getAnimatedFraction());//从可见到不可见        &#125;    &#125;);    return animator;&#125;\n这是估值器的实现123456789101112131415161718192021222324252627282930313233/** * 创建时间: 2018/5/10 * * @author Liuzj * 功能描述: 贝塞尔曲线估值器 */public class BezierEvaluator implements TypeEvaluator&lt;PointF&gt; &#123;    /**     * 拐点     */    private PointF pointF1;    private PointF pointF2;    public BezierEvaluator(PointF pointF1,PointF pointF2) &#123;        this.pointF1 = pointF1;        this.pointF2 = pointF2;    &#125;    @Override    public PointF evaluate(float v, PointF pointF, PointF t1) &#123;        PointF point = new PointF();        point.x = pointF.x*(1-v)*(1-v)*(1-v)                +3*pointF1.x*v*(1-v)* (1-v)                +3*pointF2.x*v*v*(1-v)                +t1.x*v*v*v;        point.y = pointF.y*(1-v)*(1-v)*(1-v)                +3*pointF1.y*v*(1-v)* (1-v)                +3*pointF2.y*v*v*(1-v)                +t1.y*v*v*v;        return point;    &#125;&#125;\n可能有的朋友对evaluate方法里的实现有所疑惑，其实调用贝塞尔的三阶公式,然后把点跟公式里的对应上就ok了\nEND！\nThanks\n本项目源码","tags":["属性动画","贝赛尔曲线"],"path":"2018/05/09/仿QQ好友点赞效果，属性动画+贝塞尔曲线实现/","external_link":""},{"title":"仿微信聊天列表之RecyclerView多布局","date":"2016-10-07T16:00:00.000Z","content":"最近在做关于聊天的项目，需要用到RecyclerView多布局，然而在网上却没有比较详细的讲解，于是萌生了自己写一篇的念头，可能写的不好，不喜勿喷。转载请标明出处，原创不易\n效果图不废话直接先上效果图:\n\n代码既然说到RecyclerView，那就不能不提RecyclerViewAdapter，首先我们要有一个类继承RecyclerView.Adapter,有三个必须重写的方法：\n1、onCreateViewHolder(ViewGroup parent, int viewType)，这个方法的作用判断选择哪个布局，有两个参数，第一个是viewHolder的容器，第二个参数相当于一个标识，根据标识可以绑定具体的ViewHolder。\n2、onBindViewHolder(final RecyclerView.ViewHolder holder, int position)，根据方法名，我们就可以大概知道他是绑定布局的，同样有两个参数，position是当前那一行所在的位置，来看代码既然能绑定指定的item，当然就能给指定的item设置点击事件了，我设置的点击事件是，点击吐司当前的position，长按删除当前item。\n3、getItemCount()，这个方法比较简单，绑定RecyclerView Item的数量\n4、要实现绑定多布局最关键的方法啦，getItemViewType(int position)，一个参数，根据当前的position指向指定布局，也就是为onCreateViewHolder方法提供第二个参数。\n5、然后再来看先下ViewHolder和点击事件是怎么写的吧\n6、最后再来看看Activity是实现的吧\n这里简单的说明一下，楼主用到了ButterKnife注解库，如果你没用过，那么完全没关系，用到的控件findviewbyid一下就好啦，不过这个注解库确实挺强大的，推荐学习下，网上有好多教程的，如果还不会，给我留言我可以教你。哈哈，不能说教，共同进步，共同进步…\nEnd楼主也是才接触RecyclerView控件不久，也是菜鸟一名，可能理解的不是很透彻，哪里写的不对或有什么问题欢迎在下面给我评论，喜欢的话给我点赞哦。\n本文源码，点我点我..","tags":["RecyclerView","聊天列表"],"path":"2016/10/08/仿微信聊天列表之RecyclerView多布局/","external_link":""},{"title":"如何让程序返回桌面后，重新进入时不加载启动页。","date":"2017-04-09T16:00:00.000Z","content":"因为我也是才踩完这个坑，所以就把我的解决方案放在这里了，如果有更好的解决方案，欢迎在下面给我留言。好了废话不多说了，下面就是我的解决方案在启动页的onCreate()方法中super.onCreate(savedInstanceState);之后加入这段代码if (!this.isTaskRoot()) {//判断Activity是不是任务空间的源Activity，&quot;非&quot;也就是说是被系统重新实例化出来\n    Intent mainIntent = getIntent();\n    String action = mainIntent.getAction();\n    if (mainIntent.hasCategory(Intent.CATEGORY_LAUNCHER) &amp;&amp; action.equals(Intent.ACTION_MAIN)) {\n        finish();\n        return;//finish之后改Activity活动会继续执行后面的二代马，你可以logCat验证，加return避免抛Exception\n    }\n}\n","tags":["Activity"],"path":"2017/04/10/如何让程序返回桌面后，重新进入时不加载启动页/","external_link":""},{"title":"手机连接电脑不读手机的终极解决方案","date":"2017-05-02T16:00:00.000Z","content":"解决方案\n首先在开发者选项里面把USB设置关闭\n没有开发者选项的自己百度\n关闭USB选项后，重新用数据线连接电脑\n如果还说无法识别的USB设备，请重新用数据线连接电脑，基本两三次就会成功\n如果你是开发者的话，再去打开USB设备就可以调试手机了\n\n\n\n今天遇到的这个奇葩问题的解决方案，特意记录下，希望不要让更多人在这个问题上耽误时间了\n\n","tags":["解决方案","Android开发"],"path":"2017/05/03/手机连接电脑不读手机的终极解决方案/","external_link":""},{"title":"还在为右键没有svn菜单发愁？简单几步给你变出来","date":"2016-10-08T16:00:00.000Z","content":"右键没有SVN菜单？简单几步把菜单给你变出来1、按住Ctrl + Shift + Esc , 选到“进程”栏；\n2、找到explorer.exe，结束它；\n3、点击左上角的“文件”，选新建任务\n4、在弹出来的输入框中输入explorer，也就是我们刚才结束的那个进程\n5、点击确定，返回桌面，点击右键，看！是不是出来了，哈哈\n教程到此结束，简单几步是不是把svn菜单变出来了，哈哈，希望能帮到你，谢谢浏览","tags":["SVN遇到的问题"],"path":"2016/10/09/还在为右键没有svn菜单发愁？简单几步给你变出来/","external_link":""}]';
	s = s.replace(/\\n/g, "\\n")
               .replace(/\\'/g, "\\'")
               .replace(/\\"/g, '\\"')
               .replace(/\\&/g, "\\&")
               .replace(/\\r/g, "\\r")
               .replace(/\\t/g, "\\t")
               .replace(/\\b/g, "\\b")
               .replace(/\\f/g, "\\f")
// remove non-printable and other non-valid JSON chars
	s = s.replace(/[\u0000-\u0019]+/g,"");
	var list = JSON.parse(s);
	var fuse = new Fuse(list, options);
	var el = document.getElementById('search-form');
	var newBox = $('.Card-archive').first().clone();
	el.oninput = function(event){
		var searchText = el.value;
		var result = fuse.search(searchText);
		$('.archive-cards .Card-archive').remove();
		for(var i in result){
			var anotherBox = newBox.clone();
			var dateStr = new Date(result[i].date);
			anotherBox.css('display','flex');
			var url = "";
			if(result[i].external_link !== ""){
				url = result[i].external_link;
			}else{
				url = '/' + result[i].path;
			}

			anotherBox.find('.Card-title a').text(result[i].title).attr('href', url);
			anotherBox.find('.Card-date').text(dateStr.toDateString());
			anotherBox.appendTo('.archive-cards');
		}
	}
</script>

<div class='tagcloud-container'>
<div class='tag-cloud'>
	<a href="/tags/Activity/" style="font-size: 2em; color: #d63e0a">Activity</a> <a href="/tags/Android-开发/" style="font-size: 0.8em; color: #488baf">Android 开发</a> <a href="/tags/Android开发/" style="font-size: 0.8em; color: #488baf">Android开发</a> <a href="/tags/EventBus/" style="font-size: 0.8em; color: #488baf">EventBus</a> <a href="/tags/IPC/" style="font-size: 0.8em; color: #488baf">IPC</a> <a href="/tags/RecyclerView/" style="font-size: 0.8em; color: #488baf">RecyclerView</a> <a href="/tags/SVN/" style="font-size: 0.8em; color: #488baf">SVN</a> <a href="/tags/SVN遇到的问题/" style="font-size: 0.8em; color: #488baf">SVN遇到的问题</a> <a href="/tags/Toast/" style="font-size: 0.8em; color: #488baf">Toast</a> <a href="/tags/UI/" style="font-size: 0.8em; color: #488baf">UI</a> <a href="/tags/Wifi调试/" style="font-size: 0.8em; color: #488baf">Wifi调试</a> <a href="/tags/git/" style="font-size: 0.8em; color: #488baf">git</a> <a href="/tags/《Android开发艺术探索》/" style="font-size: 0.8em; color: #488baf">《Android开发艺术探索》</a> <a href="/tags/使用手册/" style="font-size: 0.8em; color: #488baf">使用手册</a> <a href="/tags/四大组件/" style="font-size: 0.8em; color: #488baf">四大组件</a> <a href="/tags/属性动画/" style="font-size: 0.8em; color: #488baf">属性动画</a> <a href="/tags/工具/" style="font-size: 0.8em; color: #488baf">工具</a> <a href="/tags/聊天列表/" style="font-size: 0.8em; color: #488baf">聊天列表</a> <a href="/tags/解决方案/" style="font-size: 0.8em; color: #488baf">解决方案</a> <a href="/tags/读书笔记/" style="font-size: 0.8em; color: #488baf">读书笔记</a> <a href="/tags/贝赛尔曲线/" style="font-size: 0.8em; color: #488baf">贝赛尔曲线</a>
</div>
</div>

  </div>

  

<footer id='footer'>
    <div class='footer-copyright'>
        <div>
            <p> Copyright by <a href="">Liuzj </a> @ 2018</p>
            <p>Designed by: <i class="fas fa-paint-brush"></i> <a href="https://moober.cn">Moober</a> and <i class="fas fa-graduation-cap"></i> <a href="https://qutang.github.io">Qu Tang</a> &bull; Theme: <a href="https://liuzjdev.github.io/">Cutie 2.0.13-Taurus</a> &bull; Powered by <a href="http://hexo.io">Hexo.</a></p>
        </div>
    </div>
    
    <div class='footer-social'>
        
    </div>
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='Archives'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='Search'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
		
		
	</div>
	</div>
</nav>

	</div>

  



    
    
    
    
<script>
    new Valine({
        el: '#valine',
        notify:false, 
        verify:false,
        appId: 'tBcysyoj9731OUF5uYiySi1A-gzGzoHsz',
        appKey: '9Y8T0FcYUEurAkpRRfii3G2V',
        placeholder: '元芳，你怎么看',
        path:window.location.pathname, 
        avatar:'retro',
        lang: 'en'
    });
</script>








    <script src="/js/lightgallery.min.js"></script>
<script src="/js/lg-zoom.min.js"></script>
<script type='text/javascript'>
    $(document).ready(function() {
        $("#lightgallery").lightGallery(); 
        $(".article-content img").each(function(){
            console.log($(this).attr('src'))
            $(this).attr('data-src', $(this).attr('src')).lightGallery({
                selector: 'this'
            })
        });
    });
</script>






<script type='text/javascript'>

  
</script>


    <script type="text/javascript" src="https://l2.io/ip.js?var=user_ip"></script>
<script type='text/javascript'>
  
</script>


<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant type='text/javascript'>

initHeadroom();

changeLayoutOnTouchScreen();

// 
</script>



<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
