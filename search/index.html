<!DOCTYPE html>
<html lang="en">




<head>

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>Search - Liuzj的博客</title>
  

  
  
  <meta name="description" content="Android developer">
  <meta name="author" content="Liuzj">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>

<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script
src="https://code.jquery.com/jquery-3.3.1.min.js"
integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


<link rel="stylesheet" href="/.css">

  <!-- load font awesome 5 -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  

  <!-- include comment system code -->
  
    <script src="//cdn1.lncld.net/static/js/3.6.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class='header'>
	<div class="header-title">
		
		<div class='header-logo'>
			<a href='/'>
				<img src='/images/avatar.png' />
			</a>
		</div>
		<div class='header-text'>
			<h1>
				<a href="/">Liuzj的博客</a>
			</h1>
			<subtitle>
				思考一切
			</subtitle>
		</div>
		
	</div>
	<div id='header-nav'>
		



<nav id="nav">
	
	
		
			
		
		
			<div class='nav-item'>
				
					<div class="nav-name">
				
					<a class='nav-link' href="/resume/">
						<span>关于 </span>
					</a>
				</div>
			</div>
		
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='归档'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='搜索'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
			
			
		
			<div class='nav-more-item'>
					<div class="nav-name">
						<a class='nav-link' href="/resume/">
							<span>关于</span>
						</a>
					</div>
			</div>
		
		
		
	</div>
	</div>
</nav>

	</div>
</header>

 




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <style>
    body {
        background-color: white;
    }
</style>
<div class='search-container'>
	<input type="text" id='search-form'>

	<ul class="cat-list">
		
	</ul>

	<div class="archive-cards">
			<div class='Card-archive' style='display:none'>
				<div class="Card-body">
					<h3 class='Card-title'>
						<a>
						</a>
					</h3>
					<div class="Card-meta">
						<ul>
							<li><i class='fa fa-calendar'></i> <span class='Card-date'></span></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
</div>

<script src="/libs/fuse.js/dist/fuse.min.js"></script>
<script>
	var options = {
		shouldSort: true,
		threshold: 0.4,
		tokenize: true,
		location: 0,
		distance: 100,
		maxPatternLength: 32,
		minMatchCharLength: 2,
		keys: [
			"title",
			"author",
			"tags"
		]
	};
	var s = '[{"title":"仿QQ好友点赞效果，属性动画+贝塞尔曲线实现","date":"2018-05-08T16:00:00.000Z","content":"前言属性动画 和 贝赛尔曲线 已经出来很久了，很多前辈写了很多不错的文章，在此不得不感谢这些前辈无私奉献的开源精神，能让我们站在巨人的肩膀上望得更远.如果你对属性动画还不太了解可以看看郭林的文章，贝塞尔曲线的使用可以参考Lin_Zero\n效果图\n实现思路整体实现思路还是比较简单的，首先要有一个容器来装点出来的赞，然后通过属性动画对赞加一些动画效果，最后通过贝塞尔曲线使其做不规则的运动。\n代码实现好了，思路有了，咱们也废话不多说，直接上代码，首先是所有动画的实现1234567891011121314151617181920212223242526272829303132333435363738** *  实现点赞效果 平移 缩放 渐变 * @param imageView * @return 所有动画的集合 *private AnimatorSet getAnimator(final ImageView imageView) &#123;    缩放    ObjectAnimator scaleX = ObjectAnimator.ofFloat(imageView,&quot;scaleX&quot;,0.4f,1f);    ObjectAnimator scaleY = ObjectAnimator.ofFloat(imageView,&quot;scaleY&quot;,0.4f,1f);    alpha    ObjectAnimator alpha = ObjectAnimator.ofFloat(imageView,&quot;alpha&quot;,0.4f,1f);    执行三个动画    AnimatorSet enterSet = new AnimatorSet();    enterSet.setDuration(500);    enterSet.playTogether(scaleX,scaleY,alpha);    用贝塞尔曲线控制点赞的走向    ValueAnimator bezierAnimator = getBezierAnimator(imageView);    综合所有动画    AnimatorSet set = new AnimatorSet();    按顺序执行    set.playSequentially(enterSet,bezierAnimator);    添加插值器    set.setInterpolator(interpolators[random.nextInt(3)]);    set.setTarget(imageView);    set.addListener(new AnimatorListenerAdapter() &#123;        @Override        public void onAnimationEnd(Animator animation) &#123;            super.onAnimationEnd(animation);            removeView(imageView);        &#125;    &#125;);    return set;&#125;\n然后是通过贝塞尔曲线对赞的走向做了控制，代码如下1234567891011121314151617181920212223242526272829** * 通过贝塞尔曲线对赞走向做控制 * @param imageView * @return *private ValueAnimator getBezierAnimator(final ImageView imageView) &#123;    准备控制贝塞尔曲线的四个点（起始点p0,拐点p1,拐点p2,终点p3）    PointF pointF0 = new PointF((mWidth-dWidth)2,mHeight-dHeight);    PointF pointF1 = getTogglePointF(1);    PointF pointF2 = getTogglePointF(2);    PointF pointF3 = new PointF(random.nextInt(mWidth),0);    BezierEvaluator bezierEvaluator = new BezierEvaluator(pointF1,pointF2);    final ValueAnimator animator = ValueAnimator.ofObject(bezierEvaluator,pointF0,pointF3);    animator.setDuration(3000);    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;        @Override        public void onAnimationUpdate(ValueAnimator valueAnimator) &#123;            PointF pointF = (PointF) valueAnimator.getAnimatedValue();            控制属性变化            imageView.setX(pointF.x);            imageView.setY(pointF.y);            imageView.setAlpha(1 - valueAnimator.getAnimatedFraction());从可见到不可见        &#125;    &#125;);    return animator;&#125;\n这是估值器的实现123456789101112131415161718192021222324252627282930313233** * 创建时间: 2018510 * * @author Liuzj * 功能描述: 贝塞尔曲线估值器 *public class BezierEvaluator implements TypeEvaluator&lt;PointF&gt; &#123;    **     * 拐点     *    private PointF pointF1;    private PointF pointF2;    public BezierEvaluator(PointF pointF1,PointF pointF2) &#123;        this.pointF1 = pointF1;        this.pointF2 = pointF2;    &#125;    @Override    public PointF evaluate(float v, PointF pointF, PointF t1) &#123;        PointF point = new PointF();        point.x = pointF.x*(1-v)*(1-v)*(1-v)                +3*pointF1.x*v*(1-v)* (1-v)                +3*pointF2.x*v*v*(1-v)                +t1.x*v*v*v;        point.y = pointF.y*(1-v)*(1-v)*(1-v)                +3*pointF1.y*v*(1-v)* (1-v)                +3*pointF2.y*v*v*(1-v)                +t1.y*v*v*v;        return point;    &#125;&#125;\n可能有的朋友对evaluate方法里的实现有所疑惑，其实调用贝塞尔的三阶公式,然后把点跟公式里的对应上就ok了\nEND！\nThanks\n本项目源码","tags":["属性动画","贝赛尔曲线"],"path":"2018/05/09/仿QQ好友点赞效果，属性动画+贝塞尔曲线实现/","external_link":""},{"title":"Git 操作","date":"2017-11-20T16:00:00.000Z","content":"git 命令\n创建本地仓库\n\n1git init\n\n获取远程仓库\n\n12git clone [url]例：git clone https:github.comyouyourpro.git\n\n创建远程仓库\n\n12345678910111213141516 添加一个新的 remote 远程仓库git remote add [remote-name] [url]例：git remote add origin https:github.comyouyourpro.gitorigin：相当于该远程仓库的别名 列出所有 remote 的别名git remote 列出所有 remote 的 urlgit remote -v 删除一个 renotegit remote rm [name] 重命名 remotegit remote rename [old-name] [new-name]\n\n从本地仓库中删除\n\n123git rm file.txt          从版本库中移除，删除文件git rm file.txt -cached  从版本库中移除，不删除原始文件git rm -r xxx            从版本库中删除指定文件夹\n\n从本地仓库中添加新的文件\n\n12git add .                添加所有文件git add file.txt         添加指定文件\n\n提交，把缓存内容提交到 HEAD 里\n\n1git commit -m &quot;注释&quot;\n\n撤销\n\n1234567891011 撤销最近的一个提交.git revert HEAD 取消 commit + addgit reset --mixed 取消 commitgit reset --soft 取消 commit + add + local workinggit reset --hard\n\n把本地提交 push 到远程服务器\n\n12git push [remote-name] [loca-branch]:[remote-branch]例：git push origin master:master\n\n查看状态\n\n1git status\n\n从远程库中下载新的改动\n\n1git fetch [remote-name][branch]\n\n合并下载的改动到分支\n\n1git merge [remote-name][branch]\n\n从远程库中下载新的改动\n\n1234pull = fetch + mergegit pull [remote-name] [branch]例：git pull origin master\n\n分支\n\n1234567891011 列出分支git branch 创建一个新的分支git branch (branch-name) 删除一个分支git branch -d (branch-nam) 删除 remote 的分支git push (remote-name) :(remote-branch)\n\n切换分支\n\n12345 切换到一个分支git checkout [branch-name] 创建并切换到该分支git checkout -b [branch-name]\n与github建立ssh通信，让Git操作免去输入密码的繁琐。\n首先呢，我们先建立ssh密匙。\n\nssh key must begin with ‘ssh-ed25519’, ‘ssh-rsa’, ‘ssh-dss’, ‘ecdsa-sha2-nistp256’, ‘ecdsa-sha2-nistp384’, or ‘ecdsa-sha2-nistp521’.  – from github\n\n根据以上文段我们可以知道github所支持的ssh密匙类型，这里我们创建ssh-rsa密匙。在command line 中输入以下指令:ssh-keygen -t rsa去创建一个ssh-rsa密匙。如果你并不需要为你的密匙创建密码和修改名字，那么就一路回车就OK，如果你需要，请您自行Google翻译，因为只是英文问题。\n\n$ ssh-keygen -t rsaGenerating publicprivate rsa key pair.您可以根据括号中的路径来判断你的.ssh文件放在了什么地方Enter file in which to save the key (cUsersLiang Guan Quan.sshid_rsa):\n\n\n到 https:github.comsettingskeys 这个地址中去添加一个新的SSH key，然后把你的xx.pub文件下的内容文本都复制到Key文本域中，然后就可以提交了。\n\n添加完成之后 我们用ssh git@github.com 命令来连通一下github，如果你在response里面看到了你github账号名，那么就说明配置成功了。  let’s enjoy github ;)\n\ngitignore\n在本地仓库根目录创建 .gitignore 文件,可以github搜索gitignore，然后下载对应的文件丢到自己项目里即可。Win7 下不能直接创建，可以创建 “.gitignore.” 文件，后面的标点自动被忽略；\n1234.idea           过滤指定文件夹fd*            忽略根目录下的 fd 目录的全部内容；*.iml            过滤指定的所有文件!.gitignore      不忽略该文件\n","tags":["git","工具"],"path":"2017/11/21/Git操作/","external_link":""},{"title":"丢掉系统自带的矮挫丑Toast吧，打造属于你自己的Toast","date":"2016-11-03T16:00:00.000Z","content":"背景  在我们平时做demo，用系统自带的土司还可以。但是当我们在做项目的时候，如果还用系统再带的，那可能就有点low咯。所以让我们一起来打造好看的土司吧。\n效果图哈哈 或许我设计的不是太美观，但是颜色样式位置你都可以自定义，相信你会设计出更好的来\n代码实现官方提供这些方法就是方便我们原来自定义Toast的下面我们来一起看看怎么利用这些方法打造好看的土司吧\n第一步 我们首先建一个用于包装系统土司的类，然后把我们需要修改的内容传给我们定义的土司，然后在调用系统土司的方法，最后显示。第二步 我们利用LayoutInflater来构造我们想要自定义的布局作为土司的布局，首先把我们定义的布局引入，并初始化控件\n第三步 我们要给土司设置显示的文字，也就是在之前初始化控件的时候我们自己写的那个textView，现在用我们自己定义的布局来显示要土司的内容，我们当然可以也写一个方法，方便下面我们的使用\n第四步 现在我们就正式的对系统的土司妹妹动手脚咯 嘿嘿~ 如果想修改我们自定义土司的位置，可以调用系统的这个方法来实现这里多说一下，这个方法包含四个参数，第一个是土司的显示位置，我设置的是显示在中间位置，第二个参数是在x轴的位置，正数表示往右，负数往左，第三个参数是y轴的位置，正数表示往下，负数往上。这个大家可以改下参数一试便知\n第五步 土司的显示时间，这个就简单多了，直接上代码了\n第六步 就是让土司显示了，如果不显示再好看的土司我们也看不到啊\n最后一步就是模仿土司的使用了，我是这样搞的，你怎么搞都行 当然可以在封装一层使之更简洁\n总结简单几步打造属于你自己的土司，是不是有点过于简单了呢，如果喜欢就在下面给我点赞哦，如果有那描述的不清晰的也欢迎给我留言问我哦。源码点我点我点我","tags":["Toast","UI"],"path":"2016/11/04/丢掉系统自带的矮挫丑Toast吧，打造属于你自己的Toast/","external_link":""},{"title":"面试汇总","date":"2019-03-02T16:00:00.000Z","content":"Activity如与Service通信？可以通过bindService的方式，先在Activity里实现一个ServiceConnection接口，并将该接口传递给bindService()方法，在ServiceConnection接口的onServiceConnected()方法里执行相关操作。\nService的生命周期与启动方法由什么区别？\nstartService()：开启Service，调用者退出后Service仍然存在。\nbindService()：开启Service，调用者退出后Service也随即退出。\n\nService生命周期：\n\n只是用startService()启动服务：onCreate() -&gt; onStartCommand() -&gt; onDestory\n只是用bindService()绑定服务：onCreate() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory\n同时使用startService()启动服务与bindService()绑定服务：onCreate() -&gt; onStartCommnad() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory\n\nService先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？广播分为哪几种，应用场景是什么？\n普通广播：调用sendBroadcast()发送，最常用的广播。\n有序广播：调用sendOrderedBroadcast()，发出去的广播会被广播接受者按照顺序接收，广播接收者按照Priority属性值从大-小排序，Priority属性相同者，动态注册的广播优先，广播接收者还可以选择对广播进行截断和修改。\n\n广播的两种注册方式有什么区别？\n静态注册：常驻系统，不受组件生命周期影响，即便应用退出，广播还是可以被接收，耗电、占内存。\n动态注册：非常驻，跟随组件的生命变化，组件结束，广播结束。在组件结束前，需要先移除广播，否则容易造成内存泄漏。\n\n广播发送和接收的原理了解吗？\n继承BroadcastReceiver，重写onReceive()方法。\n通过Binder机制向ActivityManagerService注册广播。\n通过Binder机制向ActivityMangerService发送广播。\nActivityManagerService查找符合相应条件的广播（IntentFilterPermission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。\nBroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。\n\n广播传输的数据是否有限制，是多少，为什么要限制？ContentProvider、ContentResolver与ContentObserver之间的关系是什么？\nContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做进程间数据共享。\nContentResolver：ContentResolver可以不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。\nContentObserver：观察ContentProvider中的数据变化，并将变化通知给外界。\n\n遇到过哪些关于Fragment的问题，如何处理的？\ngetActivity()空指针：这种情况一般发生在在异步任务里调用getActivity()，而Fragment已经onDetach()，此时就会有空指针，解决方案是在Fragment里使用一个全局变量mActivity，在onAttach()方法里赋值，这样可能会引起内存泄漏，但是异步任务没有停止的情况下本身就已经可能内存泄漏，相比直接crash，这种方式显得更妥当一些。\n\nFragment视图重叠：在类onCreate()的方法加载Fragment，并且没有判断saveInstanceState==null或if(findFragmentByTag(mFragmentTag) == null)，导致重复加载了同一个Fragment导致重叠。（PS：replace情况下，如果没有加入回退栈，则不判断也不会造成重叠，但建议还是统一判断下）\n\n\n12345678@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; 在页面重启时，Fragment会被保存恢复，而此时再加载Fragment会重复加载，导致重叠 ;    if(saveInstanceState == null)&#123;     或者 if(findFragmentByTag(mFragmentTag) == null)        正常情况下去 加载根Fragment     &#125; &#125;\nAndroid里的Intent传递的数据有大小限制吗，如何解决？Intent传递数据大小的限制大概在1M左右，超过这个限制就会静默崩溃。处理方式如下：\n\n进程内：EventBus，文件缓存、磁盘缓存。\n进程间：通过ContentProvider进行款进程数据共享和传递。\n\n描述一下Android的事件分发机制？Android事件分发机制的本质：事件从哪个对象发出，经过哪些对象，最终由哪个对象处理了该事件。此处对象指的是Activity、Window与View。\nAndroid事件的分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View\nAndroid事件的分发主要由三个方法来完成，如下所示：\n123456789101112131415 父View调用dispatchTouchEvent()开始分发事件public boolean dispatchTouchEvent(MotionEvent event)&#123;    boolean consume = false;     父View决定是否拦截事件    if(onInterceptTouchEvent(event))&#123;         父View调用onTouchEvent(event)消费事件，如果该方法返回true，表示         该View消费了该事件，后续该事件序列的事件（Down、Move、Up）将不会在传递         该其他View。        consume = onTouchEvent(event);    &#125;else&#123;         调用子View的dispatchTouchEvent(event)方法继续分发事件        consume = child.dispatchTouchEvent(event);    &#125;    return consume;&#125;\n描述一下View的绘制原理？View的绘制流程主要分为三步：\n\nonMeasure：测量视图的大小，从顶层父View到子View递归调用measure()方法，measure()调用onMeasure()方法，onMeasure()方法完成测量工作。\nonLayout：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上。\nonDraw：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。onDraw()方法的绘制流程为：① 绘制视图背景。② 绘制画布的图层。 ③ 绘制View内容。④ 绘制子视图，如果有的话。⑤ 还原图层。⑥ 绘制滚动条。\n\nrequestLayout()、invalidate()与postInvalidate()有什么区别？\nrequestLayout()：该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为true，会触发onMesaure()与onLayout()方法，不一定会触发onDraw()方法。\ninvalidate()：该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为false，不会触发onMesaure()与onLayout()方法，当时会触发onDraw()方法。\npostInvalidate()：该方法功能和invalidate()一样，只是它可以在非UI线程中调用。\n\n一般说来需要重新布局就调用requestLayout()方法，需要重新绘制就调用invalidate()方法。\nScroller用过吗，了解它的原理吗？了解APK的打包流程吗，描述一下？Android的包文件APK分为两个部分：代码和资源，所以打包方面也分为资源打包和代码打包两个方面，这篇文章就来分析资源和代码的编译打包原理。\nAPK整体的的打包流程如下图所示：\n\n具体说来：\n\n通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。\n通过AIDL工具处理AIDL文件，生成相应的Java文件。\n通过Javac工具编译项目源码，生成Class文件。\n通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。\n通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。\n利用KeyStore对生成的APK文件进行签名。\n如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件的速度会更快。\n\n了解APK的安装流程吗，描述一下？APK的安装流程如下所示：\n\n\n复制APK到dataapp目录下，解压并扫描安装包。\n资源管理器解析APK里的资源文件。\n解析AndroidManifest文件，并在datadata目录下创建对应的应用数据目录。\n然后对dex文件进行优化，并保存在dalvik-cache目录下。\n将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。\n安装完成后，发送广播。\n\n当点击一个应用图标以后，都发生了什么，描述一下这个过程？点击应用图标后会去启动应用的LauncherActivity，如果LancerActivity所在的进程没有创建，还会创建新进程，整体的流程就是一个Activity的启动流程。\nActivity的启动流程图（放大可查看）如下所示：\n\n整个流程涉及的主要角色有：\n\nInstrumentation: 监控应用与系统相关的交互行为。\nAMS：组件管理调度中心，什么都不干，但是什么都管。\nActivityStarter：Activity启动的控制器，处理Intent与Flag对Activity启动的影响，具体说来有：1 寻找符合启动条件的Activity，如果有多个，让用户选择；2 校验启动参数的合法性；3 返回int参数，代表Activity是否启动成功。\nActivityStackSupervisior：这个类的作用你从它的名字就可以看出来，它用来管理任务栈。\nActivityStack：用来管理任务栈里的Activity。\nActivityThread：最终干活的人，是ActivityThread的内部类，Activity、Service、BroadcastReceiver的启动、切换、调度等各种操作都在这个类里完成。\n\n注：这里单独提一下ActivityStackSupervisior，这是高版本才有的类，它用来管理多个ActivityStack，早期的版本只有一个ActivityStack对应着手机屏幕，后来高版本支持多屏以后，就有了多个ActivityStack，于是就引入了ActivityStackSupervisior用来管理多个ActivityStack。\n整个流程主要涉及四个进程：\n\n调用者进程，如果是在桌面启动应用就是Launcher应用进程。\nActivityManagerService等所在的System Server进程，该进程主要运行着系统服务组件。\nZygote进程，该进程主要用来fork新进程。\n新启动的应用进程，该进程就是用来承载应用运行的进程了，它也是应用的主线程（新创建的进程就是主线程），处理组件生命周期、界面绘制等相关事情。\n\n有了以上的理解，整个流程可以概括如下：\n\n点击桌面应用图标，Launcher进程将启动Activity（MainActivity）的请求以Binder的方式发送给了AMS。\nAMS接收到启动请求后，交付ActivityStarter处理Intent和Flag等信息，然后再交给ActivityStackSupervisiorActivityStack处理Activity进栈相关流程。同时以Socket方式请求Zygote进程fork新进程。\nZygote接收到新进程创建请求后fork出新进程。\n在新进程里创建ActivityThread对象，新创建的进程就是应用的主线程，在主线程里开启Looper消息循环，开始处理创建Activity。\nActivityThread利用ClassLoader去加载Activity、创建Activity实例，并回调Activity的onCreate()方法。这样便完成了Activity的启动。\n\nBroadcastReceiver与LocalBroadcastReceiver有什么区别？\nBroadcastReceiver 是跨应用广播，利用Binder机制实现。\nLocalBroadcastReceiver 是应用内广播，利用Handler实现，利用了IntentFilter的match功能，提供消息的发布与接收功能，实现应用内通信，效率比较高。\n\nAndroid Handler机制是做什么的，原理了解吗？Android消息循环流程图如下所示：\n\n主要涉及的角色如下所示：\n\nMessage：消息，分为硬件产生的消息（例如：按钮、触摸）和软件产生的消息。\nMessageQueue：消息队列，主要用来向消息池添加消息和取走消息。\nLooper：消息循环器，主要用来把消息分发给相应的处理者。\nHandler：消息处理器，主要向消息队列发送各种消息以及处理各种消息。\n\n整个消息的循环流程还是比较清晰的，具体说来：\n\nHandler通过sendMessage()发送消息Message到消息队列MessageQueue。\nLooper通过loop()不断提取触发条件的Message，并将Message交给对应的target handler来处理。\ntarget handler调用自身的handleMessage()方法来处理Message。\n\n事实上，在整个消息循环的流程中，并不只有Java层参与，很多重要的工作都是在C++层来完成的。我们来看下这些类的调用关系。\n\n注：虚线表示关联关系，实线表示调用关系。\n在这些类中MessageQueue是Java层与C++层维系的桥梁，MessageQueue与Looper相关功能都通过MessageQueue的Native方法来完成，而其他虚线连接的类只有关联关系，并没有直接调用的关系，它们发生关联的桥梁是MessageQueue。\nAndroid Binder机制是做什么的，为什么选用Binder，原理了解吗？Android Binder是用来做进程通信的，Android的各个应用以及系统服务都运行在独立的进程中，它们的通信都依赖于Binder。\n为什么选用Binder，在讨论这个问题之前，我们知道Android也是基于Linux内核，Linux现有的进程通信手段有以下几种：\n\n管道：在创建时分配一个page大小的内存，缓存区大小比较有限；\n消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；\n共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；\n套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；\n信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。6. 信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；\n\n既然有现有的IPC方式，为什么重新设计一套Binder机制呢。主要是出于以上三个方面的考量：\n\n高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。\n稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于CS架构，客户端与服务端彼此独立，稳定性较好。\n安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传荣IPC只能由用户在数据包里填入UIDPID，这个标记完全是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。\n\n描述一下Activity的生命周期，这些生命周期是如何管理的？Activity与Fragment生命周期如下所示：\n\n读者可以从上图看出，Activity有很多种状态，状态之间的变化也比较复杂，在众多状态中，只有三种是常驻状态：\n\nResumed（运行状态）：Activity处于前台，用户可以与其交互。\nPaused（暂停状态）：Activity被其他Activity部分遮挡，无法接受用户的输入。\nStopped（停止状态）：Activity被完全隐藏，对用户不可见，进入后台。\n\n其他的状态都是中间状态。\n我们再来看看生命周期变化时的整个调度流程，生命周期调度流程图如下所示：\n\n所以你可以看到，整个流程是这样的：\n\n比方说我们点击跳转一个新Activity，这个时候Activity会入栈，同时它的生命周期也会从onCreate()到onResume()开始变换，这个过程是在ActivityStack里完成的，ActivityStack是运行在Server进程里的，这个时候Server进程就通过ApplicationThread的代理对象ApplicationThreadProxy向运行在app进程ApplicationThread发起操作请求。\nApplicationThread接收到操作请求后，因为它是运行在app进程里的其他线程里，所以ApplicationThread需要通过Handler向主线程ActivityThread发送操作消息。\n主线程接收到ApplicationThread发出的消息后，调用主线程ActivityThread执行响应的操作，并回调Activity相应的周期方法。\n\n注：这里提到了主线程ActivityThread，更准确来说ActivityThread不是线程，因为它没有继承Thread类或者实现Runnable接口，它是运行在应用主线程里的对象，那么应用的主线程到底是什么呢？从本质上来讲启动启动时创建的进程就是主线程，线程和进程处理是否共享资源外，没有其他的区别，对于Linux来说，它们都只是一个struct结构体。\nActivity的通信方式有哪些？\nstartActivityForResult\nEventBus\nLocalBroadcastReceiver\n\nAndroid应用里有几种Context对象，Context类图如下所示：\n\n可以发现Context是个抽象类，它的具体实现类是ContextImpl，ContextWrapper是个包装类，内部的成员变量mBase指向的也是个ContextImpl对象，ContextImpl完成了实际的功能，Activity、Service与Application都直接或者间接的继承ContextWrapper。\n描述一下进程和Application的生命周期？一个安装的应用对应一个LoadedApk对象，对应一个Application对象，对于四大组件，Application的创建和获取方式也是不尽相同的，具体说来：\n\nActivity：通过LoadedApk的makeApplication()方法创建。\nService：通过LoadedApk的makeApplication()方法创建。\n静态广播：通过其回调方法onReceive()方法的第一个参数指向Application。\nContentProvider：无法获取Application，因此此时Application不一定已经初始化。\n\nAndroid哪些情况会导致内存泄漏，如何分析内存泄漏？常见的产生内存泄漏的情况如下所示：\n\n持有静态的Context（Activity）引用。\n持有静态的View引用，\n内部类&amp;匿名内部类实例无法释放（有延迟时间等等），而内部类又持有外部类的强引用，导致外部类无法释放，这种匿名内部类常见于监听器、Handler、Thread、TimerTask\n资源使用完成后没有关闭，例如：BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap。\n不正确的单例模式，比如单例持有Activity。\n集合类内存泄漏，如果一个集合类是静态的（缓存HashMap），只有添加方法，没有对应的删除方法，会导致引用无法被释放，引发内存泄漏。\n错误的覆写了finalize()方法，finalize()方法执行执行不确定，可能会导致引用无法被释放。\n\n查找内存泄漏可以使用Android Profiler工具或者利用LeakCanary工具。\nAndroid有哪几种进程，是如何管理的？Android的进程主要分为以下几种：\n前台进程\n用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：\n\n托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）\n托管某个 Service，后者绑定到用户正在交互的 Activity\n托管正在“前台”运行的 Service（服务已调用 startForeground()）\n托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）\n托管正执行其 onReceive() 方法的 BroadcastReceiver\n\n通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。\n可见进程\n没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：\n\n托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。\n托管绑定到可见（或前台）Activity 的 Service。\n\n可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。\n服务进程\n正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。\n后台进程\n包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。\n空进程\n不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。\nActivityManagerService负责根据各种策略算法计算进程的adj值，然后交由系统内核进行进程的管理。\nSharePreference性能优化，可以做进程同步吗？在Android中, SharePreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在datadata &lt; package name &gt; shared_prefs目录下.\n之所以说SharedPreference是一种轻量级的存储方式，是因为它在创建的时候会把整个文件全部加载进内存，如果SharedPreference文件比较大，会带来以下问题：\n\n第一次从sp中获取值的时候，有可能阻塞主线程，使界面卡顿、掉帧。\n解析sp的时候会产生大量的临时对象，导致频繁GC，引起界面卡顿。\n这些key和value会永远存在于内存之中，占用大量内存。\n\n优化建议\n\n不要存放大的key和value，会引起界面卡、频繁GC、占用内存等等。\n毫不相关的配置项就不要放在在一起，文件越大读取越慢。\n读取频繁的key和不易变动的key尽量不要放在一起，影响速度，如果整个文件很小，那么忽略吧，为了这点性能添加维护成本得不偿失。\n不要乱edit和apply，尽量批量修改一次提交，多次apply会阻塞主线程。\n尽量不要存放JSON和HTML，这种场景请直接使用JSON。\nSharedPreference无法进行跨进程通信，MODE_MULTI_PROCESS只是保证了在API 11以前的系统上，如果sp已经被读取进内存，再次获取这个SharedPreference的时候，如果有这个flag，会重新读一遍文件，仅此而已。\n\n如何做SQLite升级？数据库升级增加表和删除表都不涉及数据迁移，但是修改表涉及到对原有数据进行迁移。升级的方法如下所示：\n\n将现有表命名为临时表。\n创建新表。\n将临时表的数据导入新表。\n删除临时表。\n\n重写\n如果是跨版本数据库升级，可以由两种方式，如下所示：\n\n逐级升级，确定相邻版本与现在版本的差别，V1升级到V2,V2升级到V3，依次类推。\n跨级升级，确定每个版本与现在数据库的差别，为每个case编写专门升级大代码。\n\n进程保护如何做，如何唤醒其他进程？进程保活主要有两个思路：\n\n提升进程的优先级，降低进程被杀死的概率。\n拉活已经被杀死的进程。\n\n如何提升优先级，如下所示：\n监控手机锁屏事件，在屏幕锁屏时启动一个像素的Activity，在用户解锁时将Activity销毁掉，前台Activity可以将进程变成前台进程，优先级升级到最高。\n如果拉活\n利用广播拉活Activity。\n理解序列化吗，Android为什么引入Parcelable？所谓序列化就是将对象变成二进制流，便于存储和传输。\n\nSerializable是java实现的一套序列化方式，可能会触发频繁的IO操作，效率比较低，适合将对象存储到磁盘上的情况。\nParcelable是Android提供一套序列化机制，它将序列化后的字节流写入到一个共性内存中，其他对象可以从这块共享内存中读出字节流，并反序列化成对象。因此效率比较高，适合在对象间或者进程间传递信息。\n\n如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出？Bitamp 占用内存大小 = 宽度像素 x （inTargetDensity  inDensity） x 高度像素 x （inTargetDensity  inDensity）x 一个像素所占的内存\n注：这里inDensity表示目标图片的dpi（放在哪个资源文件夹下），inTargetDensity表示目标屏幕的dpi，所以你可以发现inDensity和inTargetDensity会对Bitmap的宽高进行拉伸，进而改变Bitmap占用内存的大小。\n在Bitmap里有两个获取内存占用大小的方法。\n\ngetByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。\ngetAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存大小，代替了 getByteCount() 方法。\n\n在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片时，那么 getByteCount() 表示新解码图片占用内存的大小，getAllocationByteCount() 表示被复用 Bitmap真实占用的内存大小（即 mBuffer 的长度）。\n为了保证在加载Bitmap的时候不产生内存溢出，可以受用BitmapFactory进行图片压缩，主要有以下几个参数：\n\nBitmapFactory.Options.inPreferredConfig：将ARGB_8888改为RGB_565，改变编码方式，节约内存。\nBitmapFactory.Options.inSampleSize：缩放比例，可以参考Luban那个库，根据图片宽高计算出合适的缩放比例。\nBitmapFactory.Options.inPurgeable：让系统可以内存不足时回收内存。\n\nAndroid如何在不压缩的情况下加载高清大图？使用BitmapRegionDecoder进行布局加载。\nAndroid里的内存缓存和磁盘缓存是怎么实现的。内存缓存基于LruCache实现，磁盘缓存基于DiskLruCache实现。这两个类都基于Lru算法和LinkedHashMap来实现。\nLRU算法可以用一句话来描述，如下所示：\n\nLRU是Least Recently Used的缩写，最近最久未使用算法，从它的名字就可以看出，它的核心原则是如果一个数据在最近一段时间没有使用到，那么它在将来被访问到的可能性也很小，则这类数据项会被优先淘汰掉。\n\nLruCache的原理是利用LinkedHashMap持有对象的强引用，按照Lru算法进行对象淘汰。具体说来假设我们从表尾访问数据，在表头删除数据，当访问的数据项在链表中存在时，则将该数据项移动到表尾，否则在表尾新建一个数据项。当链表容量超过一定阈值，则移除表头的数据。\n为什么会选择LinkedHashMap呢？\n这跟LinkedHashMap的特性有关，LinkedHashMap的构造函数里有个布尔参数accessOrder，当它为true时，LinkedHashMap会以访问顺序为序排列元素，否则以插入顺序为序排序元素。\nDiskLruCache与LruCache原理相似，只是多了一个journal文件来做磁盘文件的管理和迎神，如下所示：\n12345678libcore.io.DiskLruCache111DIRTY 1517126350519CLEAN 1517126350519 5325928REMOVE 1517126350519\n注：这里的缓存目录是应用的缓存目录datadatapckagenamecache，未root的手机可以通过以下命令进入到该目录中或者将该目录整体拷贝出来：\n12345678进入datadatapckagenamecache目录adb shellrun-as com.your.packagename cp datadatacom.your.packagename将datadatapckagename目录拷贝出来adb backup -noapk com.your.packagename\n我们来分析下这个文件的内容：\n\n第一行：libcore.io.DiskLruCache，固定字符串。\n第二行：1，DiskLruCache源码版本号。\n第三行：1，App的版本号，通过open()方法传入进去的。\n第四行：1，每个key对应几个文件，一般为1.\n第五行：空行\n第六行及后续行：缓存操作记录。\n\n第六行及后续行表示缓存操作记录，关于操作记录，我们需要了解以下三点：\n\nDIRTY 表示一个entry正在被写入。写入分两种情况，如果成功会紧接着写入一行CLEAN的记录；如果失败，会增加一行REMOVE记录。注意单独只有DIRTY状态的记录是非法的。\n当手动调用remove(key)方法的时候也会写入一条REMOVE记录。\nREAD就是说明有一次读取的记录。\nCLEAN的后面还记录了文件的长度，注意可能会一个key对应多个文件，那么就会有多个数字。\n\nPathClassLoader与DexClassLoader有什么区别？\nPathClassLoader：只能加载已经安装到Android系统的APK文件，即dataapp目录，Android默认的类加载器。\nDexClassLoader：可以加载任意目录下的dex、jar、apk、zip文件。\n\nWebView优化了解吗，如何提高WebView的加载速度？为什么WebView加载会慢呢？\n\n这是因为在客户端中，加载H5页面之前，需要先初始化WebView，在WebView完全初始化完成之前，后续的界面加载过程都是被阻塞的。\n\n优化手段围绕着以下两个点进行：\n\n预加载WebView。\n加载WebView的同时，请求H5页面数据。\n\n因此常见的方法是：\n\n全局WebView。\n客户端代理页面请求。WebView初始化完成后向客户端请求数据。\nasset存放离线包。\n\n除此之外还有一些其他的优化手段：\n\n脚本执行慢，可以让脚本最后运行，不阻塞页面解析。\nDNS与链接慢，可以让客户端复用使用的域名与链接。\nReact框架代码执行慢，可以将这部分代码拆分出来，提前进行解析。\n\nJava和JS的相互调用怎么实现，有做过什么优化吗？jockeyjs：https:github.comtcoulterjockeyjs\n对协议进行统一的封装和处理。\nJNI了解吗，Java与C++如何相互调用？Java调用C++\n\n在Java中声明Native方法（即需要调用的本地方法）\n编译上述 Java源文件javac（得到 .class文件）3。 通过 javah 命令导出JNI的头文件（.h文件）\n使用 Java需要交互的本地代码 实现在 Java中声明的Native方法 \n编译.so库文件\n通过Java命令执行 Java程序，最终实现Java调用本地代码\n\nC++调用Java\n\n从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象。\n获取类的默认构造方法ID。\n查找实例方法的ID。\n创建该类的实例。\n调用对象的实例方法。\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445JNIEXPORT void JNICALL Java_com_study_jnilearn_AccessMethod_callJavaInstaceMethod  (JNIEnv *env, jclass cls)  &#123;      jclass clazz = NULL;      jobject jobj = NULL;      jmethodID mid_construct = NULL;      jmethodID mid_instance = NULL;      jstring str_arg = NULL;       1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象      clazz = (*env)-&gt;FindClass(env, comstudyjnilearnClassMethod);      if (clazz == NULL) &#123;          printf(找不到com.study.jnilearn.ClassMethod这个类);          return;      &#125;       2、获取类的默认构造方法ID      mid_construct = (*env)-&gt;GetMethodID(env,clazz, &lt;init&gt;,()V);      if (mid_construct == NULL) &#123;          printf(找不到默认的构造方法);          return;      &#125;       3、查找实例方法的ID      mid_instance = (*env)-&gt;GetMethodID(env, clazz, callInstanceMethod, (LjavalangString;I)V);      if (mid_instance == NULL) &#123;          return;      &#125;       4、创建该类的实例      jobj = (*env)-&gt;NewObject(env,clazz,mid_construct);      if (jobj == NULL) &#123;          printf(在com.study.jnilearn.ClassMethod类中找不到callInstanceMethod方法);          return;      &#125;       5、调用对象的实例方法      str_arg = (*env)-&gt;NewStringUTF(env,我是实例方法);      (*env)-&gt;CallVoidMethod(env,jobj,mid_instance,str_arg,200);       删除局部引用      (*env)-&gt;DeleteLocalRef(env,clazz);      (*env)-&gt;DeleteLocalRef(env,jobj);      (*env)-&gt;DeleteLocalRef(env,str_arg);  &#125;\n了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？\n插件化：插件化是体现在功能拆分方面的，它将某个功能独立提取出来，独立开发，独立测试，再插入到主应用中。依次来较少主应用的规模。\n热修复：热修复是体现在bug修复方面的，它实现的是不需要重新发版和重新安装，就可以去修复已知的bug。\n\n利用PathClassLoader和DexClassLoader去加载与bug类同名的类，替换掉bug类，进而达到修复bug的目的，原理是在app打包的时候阻止类打上CLASS_ISPREVERIFIED标志，然后在热修复的时候动态改变BaseDexClassLoader对象间接引用的dexElements，替换掉旧的类。\n目前热修复框架主要分为两大类：\n\nSophix：修改方法指针。\nTinker：修改dex数组元素。\n\n如何做性能优化？\n节制的使用Service，当启动一个Service时，系统总是倾向于保留这个Service依赖的进程，这样会造成系统资源的浪费，可以使用IntentService，执行完成任务后会自动停止。\n当界面不可见时释放内存，可以重写Activity的onTrimMemory()方法，然后监听TRIM_MEMORY_UI_HIDDEN这个级别，这个级别说明用户离开了页面，可以考虑释放内存和资源。\n避免在Bitmap浪费过多的内存，使用压缩过的图片，也可以使用Fresco等库来优化对Bitmap显示的管理。\n使用优化过的数据集合SparseArray代替HashMap，HashMap为每个键值都提供一个对象入口，使用SparseArray可以免去基本对象类型转换为引用数据类想的时间。\n\n如果防止过度绘制，如何做布局优化？\n使用include复用布局文件。\n使用merge标签避免嵌套布局。\n使用stub标签仅在需要的时候在展示出来。\n\n如何提交代码质量？\n避免创建不必要的对象，尽可能避免频繁的创建临时对象，例如在for循环内，减少GC的次数。\n尽量使用基本数据类型代替引用数据类型。\n静态方法调用效率高于动态方法，也可以避免创建额外对象。\n对于基本数据类型和String类型的常量要使用static final修饰，这样常量会在dex文件的初始化器中进行初始化，使用的时候可以直接使用。\n多使用系统API，例如数组拷贝System.arrayCopy()方法，要比我们用for循环效率快9倍以上，因为系统API很多都是通过底层的汇编模式执行的，效率比较高。\n\n有没有遇到64k问题，为什么会出现这个问题，如何解决？\n在DEX文件中，method、field、class等的个数使用short类型来做索引，即两个字节（65535），method、field、class等均有此限制。\nAPK在安装过程中会调用dexopt将DEX文件优化成ODEX文件，dexopt使用LinearAlloc来存储应用信息，关于LinearAlloc缓冲区大小，不同的版本经历了4M8M16M的限制，超出缓冲区时就会抛出INSTALL_FAILED_DEXOPT错误。\n\n解决方案是Google的MultiDex方案，具体参见：配置方法数超过 64K 的应用。\nMVC、MVP与MVVM之间的对比分析？\nMVC：PC时代就有的架构方案，在Android上也是最早的方案，ActivityFragment这些上帝角色既承担了V的角色，也承担了C的角色，小项目开发起来十分顺手，大项目就会遇到耦合过重，ActivityFragment类过大等问题。\nMVP：为了解决MVC耦合过重的问题，MVP的核心思想就是提供一个Presenter将视图逻辑I和业务逻辑相分离，达到解耦的目的。\nMVVM：使用ViewModel代替Presenter，实现数据与View的双向绑定，这套框架最早使用的data-binding将数据绑定到xml里，这么做在大规模应用的时候是不行的，不过数据绑定是一个很有用的概念，后续Google又推出了ViewModel组件与LiveData组件。ViewModel组件规范了ViewModel所处的地位、生命周期、生产方式以及一个Activity下多个Fragment共享ViewModel数据的问题。LiveData组件则提供了在Java层面View订阅ViewModel数据源的实现方案。\n\n","tags":["面试","基础"],"path":"2019/03/03/Android面试题集/","external_link":""},{"title":"做饭日记","date":"2019-02-11T16:00:00.000Z","content":"2019年3月16日 炒豆腐\n2019年3月13日 菠菜炖粉条\n2019年3月11日 豆角炒茄子\n2019年3月10日 芹菜炒木耳\n2019年3月7日 小炒蒜苗\n2019年3月5日 蒜黄炒鸡蛋\n2019年3月4日 别问我西红柿哪去了 我也不知道\n2019年3月3日\n2019年3月2日\n2019年2月28日\n2019年2月27日\n2019年2月26日\n2019年2月25日\n2019年2月24日\n2019年2月23日 大周末的加个凉菜\n2019年2月22日\n2019年2月21日 上面这个咸菜真的优点影响食欲了.. \n2019年2月20日\n2019年2月19日\n2019年2月18日 吃了半天想起来忘拍照留念了^_^\n2019年2月17日 刀功还有待提高！\n2019年2月16日\n2019年2月15日 上次西红柿炒鸡蛋没炒好 很是不服\n2019年2月14日 情人节庆祝庆祝加个蛋 哈哈哈\n2019年2月13日\n2019年2月12日 第一次居然做成这样 哎\n","tags":["生活","做饭"],"path":"2019/02/12/厨神养成记/","external_link":""},{"title":"《肖申克的救赎》观后感","date":"2019-01-30T16:00:00.000Z","content":"Hope is a good thing, maybe the best of things and no good thing ever dies.一直听朋友说这个片子很好， 但是一直没时间看， 今天认真看了。 \n&#8195;&#8195;这是一部成功的电影，不管你承认还是不承认。它没有绚丽的场景，华丽的特效，它场景厚朴， 画面质朴，演员淳朴，但它情节紧凑，跌宕起伏，演出自然。 整部剧没有围绕主角安迪展开，而是通过瑞德的视角把安迪带入漫长的监狱生活中。但不同的是安迪始终心怀希望，面对被体制化的肖申克，安迪仿佛是一缕光。 瑞德说的一段话我印象很深刻：“刚入狱的时候，你痛恨周围的高墙，慢慢地，你习惯了生活在其中，最终你发现，自己不得不依靠它而生存。”，布鲁克和鸽子的故事更是体现出体制化对人的伤害。\n&#8195;&#8195;整部剧中我印象最深的就是体制化这个词，剧中的人被肖申克体制化，鸽子和囚犯布鲁克的故事听后叫人毛骨悚然。一个囚犯入狱时养了一只鸽子，放风时老爱带着鸽子在运动场的一个角落晃来晃去，8年后，他刑满释放，出狱的前一天他放飞了养了8年的鸽子，鸽子立刻姿态漂亮地飞走了，可是，一个星期后，安迪在运动场的那个角落又看到了那只鸽子，鸽子像粪土一样躺在那里，鸽子已经被监狱的生活制度化了，运动场的角落成了它全部的生存空间，放飞后它又回到那里，没有无人喂养的鸽子活活饿死在那个地方。还有囚犯布鲁克，他在肖申克监狱呆了几十年，肖申克已经变成了他的整个世界，在布鲁克眼中，墙外的世界实在太可怕了，他不知道出去以后怎样生活，当他获得假释时，他一手拿着假释文件，一手拿着汽车车票，边走边哭，不到一年就死于贫苦老人之家。肖申克出来的每一个人都变成了行尸走肉，更别奢谈什么保持人性了。\nI guess it comes down to a simple choice: get busy living or get busy dying.&#8195;&#8195;Get busy living, or get busy dying ，我们现在是不是也正活在一个无形的“肖申克”中呢？是不是也在被逐渐体制化呢？我们要么忙于生存，要么赶着去死的抉择中应该怎样去选择呢？我想答案不用我说了。如何忙着活呢，安迪给了我们一个很好的例子，掌握好自己的专业技能，心存目标，坚持不懈，然后干就完了。\nSome birds aren’t meant to be caged. Their feathers are just too bright. And when they fly away，the part of you that knows it was a sin to lock them up does rejoice.（有的鸟毕竟是关不住的，他们的羽翼太光辉了，当他们飞走，你会由衷庆贺他获得自由。）\n","tags":["观后感","《肖申克的救赎》"],"path":"2019/01/31/肖申克的救赎/","external_link":""},{"title":"二零一八年终总结","date":"2018-12-30T16:00:00.000Z","content":"说两句总想说两句，又不知从何说起。都赖自己读书少，所以给自己立几个flag，好让明年有个奔头\n目标一把自己技术提升个level，既然不知道什么适合自己，那就把现在手头得工作做好。\n\n基础\n算法\n框架及源码\n争取自己搞个开源项目\n抽时间学学python，用python搭个后台玩玩\n\n目标二尽量常回家看看，多陪陪家人\n目标三带老爸老妈做个体检，毕竟健康是第一位\n目标四给老爸老妈买个新的电子产品，感受感受科技得强大\n目标五多读书，跟别人交流得时候总是有很多东西想说，却不知该怎么表达，才后悔自己读书少\n虽说现在还不知道看啥，但先给自己定个小目标，最少明年要读五本书。看后写观后感\n目标六坚持锻炼，有个好体格，才有资本谈别的\n小感慨算了，也不知道说啥了就这样吧，憋一肚子话不知道怎么表达就这样憋死我吧。\n再见2018，加油2019.让自己变得更强，变得更优秀\n2018年12月31日22点17分&emsp;\n\n\n","tags":["年终总结","目标"],"path":"2018/12/31/2018年度总结/","external_link":""},{"title":"程序设计的6大原则","date":"2018-12-03T16:00:00.000Z","content":"单一职责原则\n所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。\n一个类，只有一个引起它变化的原因。应该只有一个职责。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。\n此原则的核心就是高内聚低耦合。\n\n里氏替换原则\n里氏替换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。\n派生类（子类）对象可以在程式中代替其基类（超类）对象。\n\n依赖倒置原则\n依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。 简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\n高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。\n抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。\n\n接口隔离原则\n使用多个专门的接口比使用单一的总接口要好。\n一个类对另外一个类的依赖性应当是建立在最小的接口上的。\n一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。\n“不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。”这个说得很明白了，再通俗点说，不要强迫客户使用它们不用的方法，如果强迫用户使用它们不使用的方法，那么这些客户就会面临由于这些不使用的方法的改变所带来的改变。\n\n迪米特法则\n迪米特法则可以简单说成：talk only to your immediate friends。 对于OOD来说，又被解释为下面几种方式：一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。\n迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。\n迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。\n有兴趣可以研究一下设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则应用的例子。\n\n开闭原则\n开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的。\n开闭原则中“闭”，是指对于原有代码的修改是封闭的，即修改原有的代码对外部的使用是透明的。\n在面向对象编程领域中，开闭原则规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。该特性在产品化的环境中是特别有价值的，在这种环境中，改变源代码需要代码审查，单元测试以及诸如此类的用以确保产品使用质量的过程。遵循这种原则的代码在扩展时并不发生改变，因此无需上述的过程。\n\n以上内容均来自百度百科及维基百科，感谢观看","tags":["六大原则","设计模式"],"path":"2018/12/04/程序设计的6大原则/","external_link":""},{"title":"项目合并","date":"2018-10-13T16:00:00.000Z","content":"遇到这个任务 请务必静下心遇到这个任务 请务必静下心遇到这个任务 请务必静下心命令行查看更多错误信息编译时打印详细信息gradle build --info\ngradle build --stacktrace\n当然也能这么用\ngradle build --stacktrace --info\n运行时gradle assembledebug --stacktrace --info\n错误一、Program type already present这类问题出现得原因大多都是引用的第三方依赖重复，遇到这类问题需要别烦躁，细心找出重复得依赖删除即可消除这类问题，这里提供一种方式\n\n错误二、More than one file was found with OS independent pathandroid {\n   ---\n   packagingOptions {\n        pickFirst &apos;libx86_64替换成你错误中.so&apos;\n        pickFirst &apos;libarmeabi替换成你错误中.so&apos;\n        pickFirst &apos;libx86替换成你错误中.so&apos;\n        pickFirst &apos;libarmeabi-v7a替换成你错误中.so&apos;\n        pickFirst &apos;libarm64-v8a替换成你错误中.so&apos;\n    }\n   ---\n}\n错误三、aapt error在gradle.properties中加入下面这行代码，处理了我的这个问题\nandroid.enableAapt2=true\n错误四、finished with non-zero exit value 1敲命令，找带error的错误，然后处理\ngradlew processDebugResources --debug\n\n最后目前遇到这些问题，在遇到在更新","tags":["项目合并","踩坑"],"path":"2018/10/14/项目合并/","external_link":""},{"title":"仿QQ邮箱加载动画","date":"2018-09-19T16:00:00.000Z","content":"效果图\n代码实现**\n * 创建时间: 2018920\n *\n * @author Liuzj\n * @description 仿QQ邮箱下拉刷新动画\n *\npublic class LoadingView extends View {\n\n    **\n     * 小球数\n     *\n    private List&lt;Paint&gt; mPaints;\n\n    **\n     * 默认小球数\n     *\n    private static int DEFAULT_NUM = 3;\n\n    **\n     * 小球画笔\n     *\n    private Paint mPaint;\n    **\n     * 默认小球半径\n     *\n    private float defaultRadius = 12f;\n    **\n     * 默认小球颜色\n     *\n    private int[] ballColors = {Color.RED, Color.YELLOW, Color.BLUE};\n\n    **\n     * 小球起点位置\n     *\n    private float x = -80f;\n    ;\n\n    public LoadingView(Context context) {\n        super(context);\n        init();\n    }\n\n    public LoadingView(Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    public LoadingView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n\n    private void init() {\n        mPaints = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; DEFAULT_NUM; i++) {\n            mPaint = new Paint();\n            mPaint.setColor(ballColors[i]);\n            mPaints.add(mPaint);\n        }\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        for (int i = 0; i &lt; mPaints.size(); i++) {\n            控制小球在80和-80之间运动\n            x += 40f;\n            if (x == 80f) {\n                x = -80f;\n            }\n            控制小球大小在12至16之间徘徊\n            defaultRadius += 2f;\n            if (defaultRadius &gt; 16f) {\n                defaultRadius = 12f;\n            }\n            canvas.drawCircle(getWidth()  2 + x, getHeight()  2, defaultRadius, mPaints.get(i));\n        }\n        postInvalidateDelayed(250);\n    }\n}\n后续先初步实现效果后续再完善吧，谢谢观看\n","tags":["自定义View"],"path":"2018/09/20/仿QQ邮箱加载动画/","external_link":""},{"title":"Linux服务器清理","date":"2018-09-13T16:00:00.000Z","content":"Why?废话不多说直接来图，可以看出磁盘已经快要满了\nWhat?可以看出mnt文件夹占用的最大，然后进入mnt目录里通过命令,根据文件大小对该路径下文件排序\n\ndu -h –max-depth=1我们服务器出现磁盘快满了的原因是因为，服务器部署了多个tomcat，然后tomcat系统日志忘记屏蔽了，时间一久，导致catalina.out记录的系统日志过多，然后文件就很大，最大的一个居然占了28G,找到了原因就解决吧\n\nHow?当然是删除文件了，但是删除之后通过命令查看当前路径各文件大小\n\ndu -sh *\n\n\n发现已经小了很多了，但是奇怪的是，通过df命令查看，空间并未清理出来\n\n\n通过查资料发现一个文件在文件系统中的存放分为两个部分：数据部分和指针部分，指针位于文件系统的meta-data中，数据被删除后，这个指针就从meta-data中清除了，而数据部分存储在磁盘中，数据对应的指针从meta-data中清除后，文件数据部分占用的空间就可以被覆盖并写入新的内容，之所以出现删除access_log文件后，空间还没释放，就是因为httpd进程还在一直向这个文件写入内容，导致虽然删除了access_log文件，但文件对应的指针部分由于进程锁定，并未从meta-data中清除，而由于指针并未被删除，那么系统内核就认为文件并未被删除，因此通过df命令查询空间并未释放也就不足为奇了。\n\n最简单粗暴的解决办法就是重启，当然如果你知道那个进程占用着呢也可以重启指定进程，我们是tomcat占用，然后重启tomcat，问题就解决啦\n\n谢谢观看，希望能帮到你","tags":["Linux清理","服务器","Centos 7"],"path":"2018/09/14/Linux服务器清理/","external_link":""},{"title":"华为EMUI打不开app解决方案","date":"2018-07-27T16:00:00.000Z","content":"1、如果Manifest中有给Activity设置这个属性\nandroid:screenOrientation=”portrait”\n\n删除掉这条属性，改用在代码中设置\nsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n\n2、如果在主题中有用到这条属性，也请删除，即可解决问题\n&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;item&gt;\n\n","tags":["Bug","解决方案"],"path":"2018/07/28/华为8.0bug/","external_link":""},{"title":"ART与Dalvik","date":"2018-06-07T16:00:00.000Z","content":"Art上应用启动快，运行快，但是耗费更多存储空间，安装时间长，总的来说ART的功效就是”空间换时间”。ART: Ahead of Time Dalvik: Just in Time什么是Dalvik：Dalvik是Google公司自己设计用于Android平台的Java虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一，它可以支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行，.dex格式是专为Dalvik应用设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为独立的Linux进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。\n什么是ART:Android操作系统已经成熟，Google的Android团队开始将注意力转向一些底层组件，其中之一是负责应用程序运行的Dalvik运行时。Google开发者已经花了两年时间开发更快执行效率更高更省电的替代ART运行时。ART代表Android Runtime,其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time(JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装的时候就预编译字节码到机器语言，这一机制叫Ahead-Of-Time(AOT)编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。\nART优点：\n系统性能的显著提升\n应用启动更快、运行更快、体验更流畅、触感反馈更及时\n更长的电池续航能力\n支持更低的硬件\n\nART缺点：\n更大的存储空间占用，可能会增加10%-20%\n更长的应用安装时间\n\n","tags":["ART","Dalvik"],"path":"2018/06/08/art与dalvik区别/","external_link":""},{"title":"IPC的理解","date":"2017-05-08T16:00:00.000Z","content":"IPC\nInter-Process Communication的缩写。含义为进程间通信或跨进程通信，是指两个进程之间进行数据交换的过程。\n\n进程和线程的区别\n按照操作系统的描述，线程是CPU调度的最小单元，同时线程是一种有限的系统资源。\n进程一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程，因此进程和线程是包含与被包含的关系。\n\n多进程分为两种\n第一种情况是一个应用因为某些原因自身需要采用多线程模式来实现。\n另一种情况是当前应用需要向其他应用获取数据\n\nAndroid中的多进程模式通过给四大组件指定android:process属性，我们可以开启多线程模式\n\n进程名以”:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一进程，而进程名不以”:”开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。\nAndroid系统会为每个应用分配一个唯一的UID,具有相同UID的应用才能共享数据，两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享data目录、组件信息，还可以共享内存数据，或者说它们看起来就像是一个应用的两个部分。\n\n多进程模式的运行机制\nAndroid为每一个应用分配了一个独立的虚拟机，或者说为每个进程都分配了一个独立的虚拟机，不同的虚拟机在不同的内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生多份副本。\n所有运行在不同进程中的四大组件，只要它们之间需要通过内存来共享数据，都会共享失败。\n\n一般来说，使用多进程会造成如下几个方面的问题：\n\n静态成员和单例模式完全失效\n线程同步机制完全失效\n\n不管是锁对象还是锁全局类都无法保证线程同步，因为不同进程锁的不是同一个对象\n\nSharedPreference的可靠性下降\n\nSharedPreferences不支持两个进程同时去执行写操作，否则会导致一定几率的数据丢失，这时因为SharedPreferences底层是通过读写XML文件来实现的，并发写显然是可能出问题的，甚至并发读写都有可能发生问题\n\nApplication会多次创建\n\n运行在同一个进程中的组件是属于同一个虚拟机和同一个Application的。同理，运行在不同进程中的组件是属于两个不同的虚拟机和Application的。\nIPC基础概念介绍\nSerializable\n\n是Java所提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。使用Serializable来实现序列化相当简单，只需要在类的声明中指定一个类似下面的标识即可自动实现默认的序列化过程。\n12private static final long serialVersionUID = 8711368828010083044L\n通过Serializable方来实现对象的序列化，如下代码：1234567891011序列化过程User user = new User(0, &quot;jake&quot;, true);ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;cache.txt&quot;));out.writeObject(user);out.close();反序列化过程ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;cache.txt&quot;));User newUser = (User)in.readObject();in.close();\n原则上序列化后的数据中的serialVersionUID只有和当前类的serialVersionUID相同时才能够正常的被反序列化。serialVersionUID的详细工作机制是这样的：序列化的时候系统会把当前类的serialVersionUID写入序列化的文件中（也可能是其他的中介），当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化，否则就说明当前类和序列化的类相比发生了某些变换\n给serialVersionUID制定为1L或者采用Eclipse根据当前类结构去生成的hash值，这两者并没有本质区别。\n\n静态成员变量属于类不属于对象，所以不会参与序列化过程\n其次用transient关键字标记的成员变量不参与序列化过程\n\nParcelable接口Parcelable也是一个接口，只要实现这个接口，一个类的对象就可以实现序列化并可以通过Intent的Binder传递Parcelable的方法说明：\n\n\n\n方法\n功能\n标记位\n\n\n\n\ncreateFromParcel(Parcel in)\n从序列化的对象中创建原始对象\n\n\n\nnewArray[int size]\n创建指定长度的原始对象数组\n\n\n\nUser(Parcel in)\n从序列化的对象中创建原始对象\n\n\n\nwrite ToParcel(Parcel out, int flags)\n将当前对象写入序列化结构中，其中flags标识有两种值0或1（参见右侧标记位）。为1时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0\nPARCELABLE_WRITE_RETURN_VALUE\n\n\ndescribeContents\n返回当前对象的内容描述。如果含有文件描述符，返回1（参见右侧标记位），否则返回0，几乎所有的情况都返回0\nCONTENTS_FILE_DESCRIPTOR\n\n\n\n\n系统已经为我们提供了许多实现了Parcelable接口的类，它们都是可以直接序列化的，比如Intent、Bundle、Bitmap等，同时List和Map也可以序列化，前提是它们里面的每个元素都是可序列化的。\n\n如何选取Serializable是Java中的序列化接口，其使用起来简单但是开销很大，序列化和反序列化需要大量IO操作。而Parceleble是Android中的序列化方式，因此更适合在Android平台上，缺点是麻烦，但是效率高，这是Android推荐的序列化方式，所以我们要首选Parcelable。Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化之后通过网络传输，但是过程稍显复杂，因此在这两种情况下建议大家使用Serializable。\nBinder\n继承了IBinder接口\nBinder是一种跨进程通信方式\n是ServiceManager连接各种Manager（ActivityManager,WindowManager等）和相应ManagerService的桥梁\n从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务器会返回一个包含了服务器端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者是数据，这里的服务包含了普通服务和基于AIDL的服务\n\naidl工具根据aidl文件自动生成的java接口的解析：首先，它声明了几个接口方法，同时还声明了几个整型的id用于标识这些方法，id用于标识在transact过程中客户端所请求的到底是哪个方法；接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部的代理类Proxy来完成。所以，这个接口的核心就是它的内部类Stub和Stub内部的代理类Proxy。 下面分析其中的方法：\n\nasInterface(android.os.IBinder obj):用于将服务器端的Binder对象转化成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端是在同一进程中，那么这个方法返回的是服务端的Stub对象本身，否则返回的是系统封装的Stub.Proxy对象。\nasBinder:返回当前Binder对象\nonTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。这个方法的原型是public Boolean onTransact(int code, Parcelable data, Parcelable reply, int flags)服务端通过code可以知道客户端请求的目标方法，接着从data中取出所需的参数，然后执行目标方法，执行完毕之后，将结果写入到reply中。如果此方法返回false，说明客户端的请求失败，利用这个特性可以做权限验证(即验证是否有权限调用该服务)。\nProxy#[Method]：代理类中的接口方法，这些方法运行在客户端，当客户端远程调用此方法时，它的内部实现是：首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。\n\n首先，当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，所以如果一个远程方法是很耗时的，那么不能在UI线程发起此远程请求；其次，由于服务端的Binder方法运行在Binder的线程池中，所以不管Binder是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了。Binder两种重要的方法\nlinkToDeath\nunlinkToDeathBinder运行在服务端，如果由于某种服务端异常终止了的话会导致客户端的远程调用失败、所以Binder提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath方法可以给Binder设置一个死亡代理，当Binder死亡的时候客户端就会收到通知，然后就可以重新发起连接从而恢复连接了。如何给Binder设置死亡代理1、声明一个DeathRecipient对象、DeathRecipient是一个接口，其内部只有一个方法bindDied，实现这个方法就可以在Binder死亡的时候收到通知了。\n\n12345678910private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() &#123;    @Override    public void binderDied() &#123;        if (mRemoteBookManager == null) return;        mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, 0);        mRemoteBookManager = null;         TODO:这里重新绑定远程Service    &#125;&#125;;\n2、在客户端绑定远程服务成功之后，给binder设置死亡代理\n12mRemoteBookManager.asBinder().linkToDeath(mDeathRecipient, 0);\nAndroid的IPC方式1、 使用Bundle\nBundle实现了Parcelable接口，Activity、Service和Receiver都支持在Intent中传递Bundle数据\n2、 使用文件共享\n这种方式简单，适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题，SharedPreferences是一个特例，虽然它也是文件的一种，但是由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下、系统对它的读写就变的不可靠，当面对高并发读写访问的时候，有很大几率会丢失，因此，不建议在进程间通信中使用SharedPreferences。\n3、 使用Messenger\nMessenger是一种轻量级的IPC方案，它的底层实现就是AIDL。Messenger是以串行的方式处理请求的，即服务端只能一个个处理，不存在并发执行的情形。\n4、 使用AIDL\n大致流程：首先建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。1.AIDL支持的数据类型：基本数据类型、String和CharSequence、ArrayList、HashMap、Parcelable以及AIDL；2.某些类即使和AIDL文件在同一个包中也要显式import进来；3.AIDL中除了基本数据类，其他类型的参数都要标上方向：in、out或者inout；4.AIDL接口中支持方法，不支持声明静态变量；5.为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。6.RemoteCallbackList是系统专门提供的用于删除跨进程Listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，因为所有的AIDL接口都继承自IInterface接口。\n5、使用ContentProvider\n1.ContentProvider主要以表格的形式来组织数据，并且可以包含多个表；2.ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider；3.ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行；4.要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者；\n6、使用Socket\n套接字，分为流式套接字和用户数据报套接字两种，分别对应于网络的传输控制层中TCP和UDP协议。\n\nTCP协议是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过”三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传功能，因此具有很高的稳定性\nUDP是无连接的，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能，在性能上，UDP具有更好的效率，其缺点是不保证数据能够正确传输，尤其是在网络拥塞的情况下。\n\nBinder连接池\n当项目规模很大的时候，创建很多个Service是不对的做法，因为service是系统资源，太多的service会使得应用看起来很重，所以最好是将所有的AIDL放在同一个Service中去管理。整个工作机制是：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。\n建议在AIDL开发工作中引入BinderPool机制。\n\n选用合适的IPC方式\n","tags":["IPC","《Android开发艺术探索》","读书笔记"],"path":"2017/05/09/《Android开发艺术探索》第二章笔记/","external_link":""},{"title":"手机连接电脑不读手机的终极解决方案","date":"2017-05-02T16:00:00.000Z","content":"解决方案\n首先在开发者选项里面把USB设置关闭\n没有开发者选项的自己百度\n关闭USB选项后，重新用数据线连接电脑\n如果还说无法识别的USB设备，请重新用数据线连接电脑，基本两三次就会成功\n如果你是开发者的话，再去打开USB设备就可以调试手机了\n\n\n\n今天遇到的这个奇葩问题的解决方案，特意记录下，希望不要让更多人在这个问题上耽误时间了\n\n","tags":["解决方案","Android开发"],"path":"2017/05/03/手机连接电脑不读手机的终极解决方案/","external_link":""},{"title":"如何让程序返回桌面后，重新进入时不加载启动页。","date":"2017-04-09T16:00:00.000Z","content":"因为我也是才踩完这个坑，所以就把我的解决方案放在这里了，如果有更好的解决方案，欢迎在下面给我留言。好了废话不多说了，下面就是我的解决方案在启动页的onCreate()方法中super.onCreate(savedInstanceState);之后加入这段代码if (!this.isTaskRoot()) {判断Activity是不是任务空间的源Activity，&quot;非&quot;也就是说是被系统重新实例化出来\n    Intent mainIntent = getIntent();\n    String action = mainIntent.getAction();\n    if (mainIntent.hasCategory(Intent.CATEGORY_LAUNCHER) &amp;&amp; action.equals(Intent.ACTION_MAIN)) {\n        finish();\n        return;finish之后改Activity活动会继续执行后面的二代马，你可以logCat验证，加return避免抛Exception\n    }\n}\n","tags":["Activity"],"path":"2017/04/10/如何让程序返回桌面后，重新进入时不加载启动页/","external_link":""},{"title":"EventBus使用笔记","date":"2017-03-01T16:00:00.000Z","content":"概念EventBus是一款针对Android优化的发布订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。EventBus源码点我使用1、准备工作因为我使用的是Android Studio，所以第一步要添加依赖：\n￼\n2、基本用法1、在需要接收事件分发的页面注册EventBusEventBus.getDefault().register(this);\n2、在第二个页面或其他需要发送事件，发送事件使用的是post方法，里面是一个object参数，我们可以自己定义一个类，然后把这个实例传递进去EventBus.getDefault().post(new EventParam());\n3、当然就是在注册事件分发的页面接收传递过来的事件了，有四种方法：  onEvent()：在哪个线程发的消息，就在哪个线程执行。 onEventMainThread()：无论在哪个线程发布，都在主线程执行 onEventBackground()：如果在主线程发布的，他会在子线程执行，如果在子线程发布，那么他会在其他子线程执行。 onEventAsync()：无论在哪个线程发布的都会新创建一个线程执行\n4、一定要在注册EventBus结束的时候解除绑定 EventBus.getDefault().unregister(this);\n3、进阶，上面已经说了四个方法的使用了，下面说下怎么区别这四个方法。 就一句话，根据传递进来的参数，参数相同的就会被执行，不同的则不执行\n","tags":["EventBus"],"path":"2017/03/02/EventBus使用笔记/","external_link":""},{"title":"Android开发配置wifi调试教程","date":"2016-12-17T16:00:00.000Z","content":"背景由于之前一直用数据线调试，手机连接电脑，手机一直处于充电状态，就导致了电池特别不着用，开始充一次电可以用两天左右，调试了不到俩月，现在充满电用不了一天就没电了。所以还是推荐通过wifi调试，第一对手机电池好，第二炫酷呀，可以装x。哈哈，下面我介绍两种方式：\n第一种：针对没数据线时这种情况第一步、需要手机先下载个安卓终端模拟器，当然去网上搜也有很多的，打开终端，依次执行下面步骤第二步、点击你连接的wifi，然后看下面有你的ip地址，记下来第三步、在电脑上，上运行cmd命令提示符，键入如下命令：\nadb connect 上一步让你记得ip地址:5555\n如果没有把adb配置到环境变量里，则需要要先 cd到adb的目录中在执行上述步骤如果提示连接成功，则说明搞定了。\n第二种：针对Android Studio，相对第一种简单很多第一步、先打开安卓studio的Settings-&gt; Plugins-&gt; Browse Repositories，在里面搜索ADB WiFI第二步，重启studio，哈哈第三步、也是关键的一步，直接看下图直接点击ADB USB to WIFI就ok了。\n最后体验炫酷的wifi调试吧。\n","tags":["Wifi调试","Android 开发"],"path":"2016/12/18/Android开发配置wifi调试教程/","external_link":""},{"title":"还在为右键没有svn菜单发愁？简单几步给你变出来","date":"2016-10-08T16:00:00.000Z","content":"右键没有SVN菜单？简单几步把菜单给你变出来1、按住Ctrl + Shift + Esc , 选到“进程”栏；\n2、找到explorer.exe，结束它；\n3、点击左上角的“文件”，选新建任务\n4、在弹出来的输入框中输入explorer，也就是我们刚才结束的那个进程\n5、点击确定，返回桌面，点击右键，看！是不是出来了，哈哈\n教程到此结束，简单几步是不是把svn菜单变出来了，哈哈，希望能帮到你，谢谢浏览","tags":["SVN遇到的问题"],"path":"2016/10/09/还在为右键没有svn菜单发愁？简单几步给你变出来/","external_link":""},{"title":"仿微信聊天列表之RecyclerView多布局","date":"2016-10-07T16:00:00.000Z","content":"最近在做关于聊天的项目，需要用到RecyclerView多布局，然而在网上却没有比较详细的讲解，于是萌生了自己写一篇的念头，可能写的不好，不喜勿喷。转载请标明出处，原创不易\n效果图不废话直接先上效果图:\n\n代码既然说到RecyclerView，那就不能不提RecyclerViewAdapter，首先我们要有一个类继承RecyclerView.Adapter,有三个必须重写的方法：\n1、onCreateViewHolder(ViewGroup parent, int viewType)，这个方法的作用判断选择哪个布局，有两个参数，第一个是viewHolder的容器，第二个参数相当于一个标识，根据标识可以绑定具体的ViewHolder。\n2、onBindViewHolder(final RecyclerView.ViewHolder holder, int position)，根据方法名，我们就可以大概知道他是绑定布局的，同样有两个参数，position是当前那一行所在的位置，来看代码既然能绑定指定的item，当然就能给指定的item设置点击事件了，我设置的点击事件是，点击吐司当前的position，长按删除当前item。\n3、getItemCount()，这个方法比较简单，绑定RecyclerView Item的数量\n4、要实现绑定多布局最关键的方法啦，getItemViewType(int position)，一个参数，根据当前的position指向指定布局，也就是为onCreateViewHolder方法提供第二个参数。\n5、然后再来看先下ViewHolder和点击事件是怎么写的吧\n6、最后再来看看Activity是实现的吧\n这里简单的说明一下，楼主用到了ButterKnife注解库，如果你没用过，那么完全没关系，用到的控件findviewbyid一下就好啦，不过这个注解库确实挺强大的，推荐学习下，网上有好多教程的，如果还不会，给我留言我可以教你。哈哈，不能说教，共同进步，共同进步…\nEnd楼主也是才接触RecyclerView控件不久，也是菜鸟一名，可能理解的不是很透彻，哪里写的不对或有什么问题欢迎在下面给我评论，喜欢的话给我点赞哦。\n本文源码，点我点我..","tags":["RecyclerView","聊天列表"],"path":"2016/10/08/仿微信聊天列表之RecyclerView多布局/","external_link":""},{"title":"Android Studio SVN使用手册","date":"2016-09-05T16:00:00.000Z","content":"Android Studio 配置及使用：\n下载客户端：下载地址:http:tortoisesvn.netdownloads.html\n安装配置：这个需要自己独立安装带有 command line 功能的 SVN 客户端，据说 1.7 之后开始支持 command line 模式。如图，安装时必须自定义选择 command line 否则不会安装的安装完成后，打开 IDE 的 setting 配置面板：如上图路径 Version Control 下的 Subersion 设置：Use Command Line Client 选择浏览到你本地安装 TortoiseSVN 的 svn.exe 文件路径，如下图：（注意输入框最右侧有个浏览的按钮，有可能没显示出来，拉伸窗口即可见）然后在setting 点击Version Control，配置成下图样子3.提交、签出 SVN 这个比较繁琐的也是容易出错的（当然你会了也就不繁琐了 哈哈）：\n\n推荐使用这种方式，先share到服务器指定目录，这样做的意思是，先和服务器建立链接，注意share完之后服务器还是没有你的代码，只是单纯的和服务器建立了链接关系。如果想让你的代码同步到服务器则需要commit一下，commit之后你的代码就正式传到服务器上了。这时你在修改文件就会变颜色，每种颜色都对应一种状态，具体的自己体会吧。特别说明一点：如果不需要提交忽略文件到服务器的话，需要在和服务器建立关联（share）之前添加忽略文件，之后添加忽略仿佛没有什么效果。在Android中不推荐直接把项目import到服务器，因为这样在以后并没有和服务器建立关联，也就导致在以后工作中会出现一些问题，具体问题可百度，有很多，楼主在这就不详细说了\n\nIgnore 指定忽略文件或目录AndroidStudio 的 Setting–&gt;Version control –&gt;Ignored files，具体怎么添加忽略文件我也不说了，网上也有很多教程然后就可以提交到服务器了,对于更新和提交这两个小按钮很方面操作，向上的绿色是commit ，向下的蓝色 是 update注意：SVN是以服务器为准的，如果需要更新，首先需要把服务器上的checkout到本地，然后在Update project 如果update后服务器没有修改，则需要commit changes更新操作:如在MainActivity中添加了几行注释：这时SVN就会用本地文件对照服务器，发现有修改的文件，就会把对应的文件名变色如果要更新的话，点击向下箭头，update project弹出这个界面，选ok下面的version control就会有所提示这样我们就可以看到Version control 提示更新了，MainActivity文件颜色也和其他的一样了。我也时才从这个坑跳出来，希望能帮到你，如果有什么问题请在下面评论，我会认真看的。大家共同学习成长\n\n","tags":["SVN","使用手册"],"path":"2016/09/06/Android Studio SVN使用手册/","external_link":""},{"title":"Activity总结","date":"2016-05-07T16:00:00.000Z","content":"看了标题也许你会想，也许你会说，activity我天天用，我最了解不过了，没有什么是我不清楚的。你怕是在唬我吧？那下面就看看我说的这些你都了解嘛\n基础知识\n正常情况下的生命周期\nonCreate：表示Activity正在被创建，我们可以做一些初始化工作，没啥子可说的。\n\nonRestart：当当前Activity从不可见重新变为可见状态时，该方法会被调用。\n\nonStart：这时Activity已经可见的，但是处于后台，无法和用户交互。\n\nonResume：这时Activity已经可见的，但是处于前台。\n\nonPause：在这个方法可以做一些存储数据，停止动画的操作，但是不能太耗时，因为这会影响到新Activity的显示，onPause必须执行完，新Activity的onResume才会执行。\n\nonStop:Activity即将停止，可以做一些稍微重量级的回收工作，同样不能太耗时。\n\nonDestory:表示Activity即将销毁，我们可以做一些回收工作和资源释放工作。\nActivity第一次启动会调用onCreate–&gt;onStart–&gt;onResume,当用户打开新的Activity或者切换到桌面的时候，会调用onPause–&gt;onStop，如果这个Activity采用透明主题，不会调用onStop,是因为新Activity透明主题我们还能看到下面那个之前Activity，所以不会调用onStop，再回到原Activity时调用onRestart–&gt;onStart–&gt;onResume.\n\n\n\n异常情况下的生命周期\n资源相关的系统配置发生改变导致Avtivity被杀死并重新创建\n\n资源不足时导致优先级低的Activity被杀死\n\n…\nActivity会调用onSaveInstanceState方法，系统自动为我们做了一定的恢复工作，并且重启为我们恢复这些数据，比如文本框中用户输入的数据，listView滚动位置等，具体的我们可以查看特定View的源码。\n\n\n\nActivity的启动模式  1、使用场景\n\nstandard：当需要每次请求都新开一个实例的时候，比如，浏览器开多个浏览窗口。\n\nsingleTop：适合作为接受通知的启动界面，比如，客户端收到10条推送，如果是标准模式，分别点击这10个推送，就会启动10个这样的显示内容的界面，而如果是singleTop，则只会打开一个显示界面。\n\nsingleTask：适合作为程序的入口，不管其他程序打开该界面多少次，都只会在任务栈中存在一份，比如浏览器的启动界面。\n\nsingleInstance：适合永远都不会变化的界面，比如闹钟的提醒界面，在比如拨号程序的呼叫界面。\n2、IntentFilter的匹配规则\n\naction的匹配规则：要求Intent中的action存在且必须和过滤规则中的其中一个action相同，这个区分大小写，如果相同的字符串，大小写字母不同，action会匹配失败。\n\ncategory匹配规则：这个可有可无，如果有，则必须和过滤规则中的其中一个category相同，如果不写的话，在启动Activity时系统会自动加上”android.intent.category.DEFAULT”\n\ndata可进一步分为uri（由scheme、host、port、path | pathPattern | pathPrefix这4部分组成）和mimetype。Intent的uri可通过setData方法设置，mimetype可通过setType方法设置。隐式Intent也必须指定data。同action类似，只要Intent的data只要与Intent Filter中的任一个data声明完全相同，data方面就匹配成功。需要注意的是：若Intent Filter的data声明部分未指定uri，则缺省uri为content或file，Intent中的uri的scheme部分需为content或file才能匹配；若要为Intent指定完整的data，必须用setDataAndType方法，原因请看setData和setType方法的源码：\n\n\n\n\n\npublic Intent setData(Uri data) {\n    mData = data;\n    mType = null;\n    return this;\n}\n\npublic Intent setType(String type) {\n    mData = null;\n    mType = type;\n    return this;\n}\n\n\n从以上代码可以看到，setData会把mimeType置为null，setType会把uri置为null。下面我们来举例说明一下data的匹配。首先我们先来看一下Intent Filter中指定data的语法：\n&lt;data android:scheme=&quot;...“\n      android:host=&quot;...&quot;\n      android:port=&quot;...&quot;\n      android:path=&quot;...&quot;\n      android:pathPattern=&quot;...&quot;\n      android:pathPrefix=&quot;...&quot;\n      android:mimeType=&quot;...&quot; &gt;\n其中scheme、host等各个部分无需全部指定。假如我们为MyActivity的Intent Filter指定了如下data：\n&lt;intent-filter&gt;\n    &lt;data android:mimeType=&quot;vidoempeg&quot; android:scheme=&quot;http&quot; android:host=&quot;www.xxx.com&quot; &gt;\n    &lt;data android:mimeType=&quot;textplain&quot; android:scheme=&quot;http&quot; &gt;\n&lt;intent-filter&gt;\n那么我们的Intent想要匹配，mimeType可以为”textplain”或“videompeg”,scheme必须为”http“，host则没有限制，因为第二个data没有指定host。\n最后这就是我知道的关于activity的一些知识，若有叙述不清晰或是不准确的地方希望大家指出，如果你知道更多知识，欢迎给我评论，大家一起学习进步。谢谢观看\n参考资料 《Android开发艺术探索》","tags":["四大组件","Activity"],"path":"2016/05/08/Activity总结/","external_link":""}]';

	s = s.replace(/\\n/g, "\\n")
               .replace(/\\'/g, "\\'")
               .replace(/\\"/g, '\\"')
               .replace(/\\&/g, "\\&")
               .replace(/\\r/g, "\\r")
               .replace(/\\t/g, "\\t")
               .replace(/\\b/g, "\\b")
               .replace(/\\f/g, "\\f")

// remove non-printable and other non-valid JSON chars
	s = s.replace(/[\u0000-\u0019]+/g,"");
	var list = JSON.parse(s);
	var fuse = new Fuse(list, options);
	var el = document.getElementById('search-form');
	var newBox = $('.Card-archive').first().clone();
	el.oninput = function(event){
		var searchText = el.value;
		var result = fuse.search(searchText);
		$('.archive-cards .Card-archive').remove();
		for(var i in result){
			var anotherBox = newBox.clone();
			var dateStr = new Date(result[i].date);
			anotherBox.css('display','flex');
			var url = "";
			if(result[i].external_link !== ""){
				url = result[i].external_link;
			}else{
				url = '/' + result[i].path;
			}

			anotherBox.find('.Card-title a').text(result[i].title).attr('href', url);
			anotherBox.find('.Card-date').text(dateStr.toDateString());
			anotherBox.appendTo('.archive-cards');
		}
	}
</script>

<div class='tagcloud-container'>
<div class='tag-cloud'>
	<a href="/tags/ART/" style="font-size: 0.8em; color: #488baf">ART</a> <a href="/tags/Activity/" style="font-size: 2em; color: #d63e0a">Activity</a> <a href="/tags/Android-开发/" style="font-size: 0.8em; color: #488baf">Android 开发</a> <a href="/tags/Android开发/" style="font-size: 0.8em; color: #488baf">Android开发</a> <a href="/tags/Bug/" style="font-size: 0.8em; color: #488baf">Bug</a> <a href="/tags/Centos-7/" style="font-size: 0.8em; color: #488baf">Centos 7</a> <a href="/tags/Dalvik/" style="font-size: 0.8em; color: #488baf">Dalvik</a> <a href="/tags/EventBus/" style="font-size: 0.8em; color: #488baf">EventBus</a> <a href="/tags/IPC/" style="font-size: 0.8em; color: #488baf">IPC</a> <a href="/tags/Linux清理/" style="font-size: 0.8em; color: #488baf">Linux清理</a> <a href="/tags/RecyclerView/" style="font-size: 0.8em; color: #488baf">RecyclerView</a> <a href="/tags/SVN/" style="font-size: 0.8em; color: #488baf">SVN</a> <a href="/tags/SVN遇到的问题/" style="font-size: 0.8em; color: #488baf">SVN遇到的问题</a> <a href="/tags/Toast/" style="font-size: 0.8em; color: #488baf">Toast</a> <a href="/tags/UI/" style="font-size: 0.8em; color: #488baf">UI</a> <a href="/tags/Wifi调试/" style="font-size: 0.8em; color: #488baf">Wifi调试</a> <a href="/tags/git/" style="font-size: 0.8em; color: #488baf">git</a> <a href="/tags/《Android开发艺术探索》/" style="font-size: 0.8em; color: #488baf">《Android开发艺术探索》</a> <a href="/tags/《肖申克的救赎》/" style="font-size: 0.8em; color: #488baf">《肖申克的救赎》</a> <a href="/tags/使用手册/" style="font-size: 0.8em; color: #488baf">使用手册</a> <a href="/tags/做饭/" style="font-size: 0.8em; color: #488baf">做饭</a> <a href="/tags/六大原则/" style="font-size: 0.8em; color: #488baf">六大原则</a> <a href="/tags/四大组件/" style="font-size: 0.8em; color: #488baf">四大组件</a> <a href="/tags/基础/" style="font-size: 0.8em; color: #488baf">基础</a> <a href="/tags/属性动画/" style="font-size: 0.8em; color: #488baf">属性动画</a> <a href="/tags/工具/" style="font-size: 0.8em; color: #488baf">工具</a> <a href="/tags/年终总结/" style="font-size: 0.8em; color: #488baf">年终总结</a> <a href="/tags/服务器/" style="font-size: 0.8em; color: #488baf">服务器</a> <a href="/tags/生活/" style="font-size: 0.8em; color: #488baf">生活</a> <a href="/tags/目标/" style="font-size: 0.8em; color: #488baf">目标</a> <a href="/tags/聊天列表/" style="font-size: 0.8em; color: #488baf">聊天列表</a> <a href="/tags/自定义View/" style="font-size: 0.8em; color: #488baf">自定义View</a> <a href="/tags/观后感/" style="font-size: 0.8em; color: #488baf">观后感</a> <a href="/tags/解决方案/" style="font-size: 2em; color: #d63e0a">解决方案</a> <a href="/tags/设计模式/" style="font-size: 0.8em; color: #488baf">设计模式</a> <a href="/tags/读书笔记/" style="font-size: 0.8em; color: #488baf">读书笔记</a> <a href="/tags/贝赛尔曲线/" style="font-size: 0.8em; color: #488baf">贝赛尔曲线</a> <a href="/tags/踩坑/" style="font-size: 0.8em; color: #488baf">踩坑</a> <a href="/tags/面试/" style="font-size: 0.8em; color: #488baf">面试</a> <a href="/tags/项目合并/" style="font-size: 0.8em; color: #488baf">项目合并</a>
</div>
</div>

  </div>

  

<footer id='footer'>
    <div class='footer-copyright'>
        <div>
            <p> 版权所有 <a href="">Liuzj </a> @ 2019</p>
            <p>设计: <i class="fas fa-paint-brush"></i> <a href="https://moober.cn">Moober</a> 和 <i class="fas fa-graduation-cap"></i> <a href="https://qutang.github.io">Qu Tang</a> &bull; 主题: <a href="https://liuzjdev.github.io/">Cutie 2.1.3-Taurus</a> &bull; 由 <a href="http://hexo.io">Hexo.</a> 强力驱动</p>
        </div>
    </div>
    
    <div class='footer-social'>
        
    </div>
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
		
			
				
			
		
		
	
	
	<div class='nav-item' id='nav-item-archive'>
		
				<div class='nav-icon'>
				
			<a href="/archives/" title='归档'>
			<img src="/images/icons/blue-shadow/archive.svg" alt="">
			</a>
		</div>
	</div>
	<div class='nav-item' id='nav-item-search'>
		
		<div class='nav-icon active_dot'>
		
			<a href="/search/" title='搜索'>
			<img src="/images/icons/blue-shadow/search.svg" alt="">
			</a>
		</div>
	</div>
	<div class="nav-item" id='nav-item-more'>
		<div class="nav-icon">
				<a href='#' onclick='onClickMenuIcon(event);' ontouchstart='onClickMenuIcon(event);'>
				<img src="/images/icons/blue-shadow/menu.svg" alt="">
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id='nav-more-menu-close' onclick='onClickNavMenuClose(event);' ontouchstart='onClickNavMenuClose(event);'></i>
		
			
			
		
			<div class='nav-more-item'>
					<div class="nav-name">
						<a class='nav-link' href="/resume/">
							<span>关于</span>
						</a>
					</div>
			</div>
		
		
		
	</div>
	</div>
</nav>

	</div>

  



    
    
    
    
<script>
    new Valine({
        el: '#valine',
        notify:false, 
        verify:false,
        appId: 'tBcysyoj9731OUF5uYiySi1A-gzGzoHsz',
        appKey: '9Y8T0FcYUEurAkpRRfii3G2V',
        placeholder: '元芳，你怎么看',
        path:window.location.pathname, 
        avatar:'retro',
        lang: 'en'
    });
</script>








    <script src="/js/lightgallery.min.js"></script>
<script src="/js/lg-zoom.min.js"></script>
<script type='text/javascript'>
    $(document).ready(function() {
        $("#lightgallery").lightGallery(); 
        $(".article-content img").each(function(){
            console.log($(this).attr('src'))
            $(this).attr('data-src', $(this).attr('src')).lightGallery({
                selector: 'this'
            })
        });
    });
</script>






<script type='text/javascript'>

  
</script>


    
<script type='text/javascript'>
  
</script>

<script type="application/javascript" src="https://api.ipify.org?format=jsonp&callback=getIP"></script>



<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant type='text/javascript'>

initHeadroom();

changeLayoutOnTouchScreen();

// 
</script>


<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
